<!-- Created by Oley Birkeland -->

{% extends 'header_fullscreen.html' %}
<!-- ^^ This means add this file into the contents of the header page -->
<!-- This is where the title, top buttons, and stylesheet is located -->

<!-- Change title here -->
{% block title %}Turn-Cringe Fighter{% endblock %}

<!-- Extra style declarations here -->
{% block style %}
  <style>
    :root {
      --attack-x: 0;
      --attack-y: 0;
    }

    body {
      user-select: none;
    }

    div, h1, input[type="text"], button, iframe {
      position: absolute;
      box-sizing: border-box;
    }

    h1 {
      margin: 0;
      font-size: 48px;
    }

    h2 {
      margin: 0;
      font-size: 32px;
    }

    h3 {
      margin: 0;
      font-size: 20px;
    }

    h4 {
      margin: 0;
      font-size: 16px;
    }

    button {
      width: 112px;
      height: 40px;
    }

    .backButton {
      left: 16px;
      top: 16px;
    }

    #randomButton {
      position: relative;
      margin-top: 8px;
    }

    .randomIcon {
      height: 16px;
      vertical-align: -1px;
    }

    input[type="text"] {
      width: 160px;
      height: 40px;
      padding: 4px;
      font-size: 18px;
      text-align: center;
    }

    #border > * {
      position: fixed;
      width: 50%;
      height: 50%;
      border-width: 8px;
    }

    #topLeftBorder {
      top: 0;
      left: 0;
      border-style: solid none none solid;
      border-color: var(--color-red);
    }

    #topRightBorder {
      top: 0;
      right: 0;
      border-style: solid solid none none;
      border-color: var(--color-yellow);
    }

    #bottomLeftBorder {
      bottom: 0;
      left: 0;
      border-style: none none solid solid;
      border-color: var(--color-green);
    }

    #bottomRightBorder {
      bottom: 0;
      right: 0;
      border-style: none solid solid none;
      border-color: var(--color-blue);
    }

    .large {
      font-size: 18px;
    }

    #findMatches {
      right: 8px;
      top: 8px;
      width: 36px;
      height: 36px;
      padding: 4px;
      font-size: 20px;
      border-radius: 4px;
      cursor: pointer;
    }

    #findMatches:hover {
      background: var(--bg-dark-highlight);
    }

    #matches {
      width: calc(100% - 64px);
      display: grid;
      grid-template-columns: repeat(2, calc(50% - 2px));
      gap: 4px;
      margin-top: 8px;
      text-align: left;
    }

    .match {
      position: static;
      padding: 8px;
      cursor: pointer;
    }

    .match:not(.pressed):hover {
      background: var(--bg-dark-highlight);
    }

    .targetOption:hover {
      cursor: pointer;
      filter: drop-shadow(0 0 6px white);
    }

    .fighter {
      width: 450px;
      height: 280px;
      padding: 8px;
      border-radius: 8px;
      color: var(--bg-dark);
      font-size: 14px;
    }

    .redBg {
      background: #fbb;
    }

    .yellowBg {
      background: #ffb;
    }

    .greenBg {
      background: #bfb;
    }

    .blueBg {
      background: #bdf;
    }

    .orangeBg {
      background: #fc9;
    }

    .magentaBg {
      background: #fbf;
    }

    .grayBg {
      background: #ddd;
    }

    .goldBg {
      background: linear-gradient(to bottom right, #fea, #ba4, #fea, #ba4);
    }

    .effect:not(.hidden) {
      position: static;
      display: inline-block;
      padding: 2px 4px;
      color: white;
      border: 1px solid;
      cursor: help;
    }

    .fighterEffects {
      right: 8px;
      top: 9px;
    }

    .fighterEffects > .effect {
      border-color: var(--bg-dark);
    }

    .HPBar {
      position: static;
      width: 75%;
      height: 12px;
      display: inline-block;
      vertical-align: middle;
      margin-right: 8px;
      border: 1px solid var(--bg-dark);
      border-radius: 6px;
      background: var(--color-green);
    }

    .showHPChange {
      animation: showHPChange 1.5s;
    }

    @keyframes showHPChange {
      0% {
        opacity: 0;
      }
      33% {
        opacity: 1;
      }
      67% {
        opacity: 1;
      }
      100% {
        opacity: 0;
      }
    }

    .move {
      position: relative;
      left: -8px;
      width: 100%;
      box-sizing: content-box;
      padding: 4px 8px;
      margin: 4px 0;
    }

    .move.enabled {
      cursor: pointer;
    }

    .move.enabled:hover {
      background: #0003;
    }

    .chargeSquare {
      position: static;
      width: 8px;
      height: 8px;
      display: inline-block;
      vertical-align: middle;
      margin: 2px;
      border: 1px solid var(--dark-gray);
    }

    .charged {
      background: var(--color-orange);
    }

    .items {
      border-radius: 48px;
      background: var(--light-gray);
      text-align: center;
    }

    .items.vertical {
      width: 96px;
      height: 256px;
    }

    .vertical > .itemSlot {
      margin: 16px;
    }

    .itemSlot {
      position: static;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: var(--bg-darker);
    }

    .filled {
      background: transparent;
    }

    .itemSlot > .item {
      width: 100%;
    }

    .item {
      border-radius: 50%;
    }

    #resetStats {
      color: var(--light-red);
      cursor: pointer;
    }

    #resetStats:active {
      filter: brightness(75%);
    }

    #findMatch, #enterCode, #createMatch {
      width: 400px;
      height: 300px;
      padding: 32px;
      border: 1px solid var(--light-green);
      text-align: center;
    }

    #matchOver > * {
      position: static;
    }

    #fighterOptions {
      background : var(--bg-darker);
      border: solid 1px;
      left: 5%;
      width: 90%;
      padding: 16px;
      display: grid;
      grid-template-columns: repeat(4, 450px);
      grid-template-rows: repeat(2, 280px);
      gap: 32px;
      overflow: auto;
    }

    #redFighter {
      grid-column: 1;
      grid-row: 1;
    }

    #yellowFighter {
      grid-column: 1;
      grid-row: 2;
    }

    #greenFighter {
      grid-column: 2;
      grid-row: 1;
    }

    #blueFighter {
      grid-column: 2;
      grid-row: 2;
    }

    #orangeFighter {
      grid-column: 3;
      grid-row: 1;
    }

    #magentaFighter {
      grid-column: 3;
      grid-row: 2;
    }

    #grayFighter {
      grid-column: 4;
      grid-row: 1;
    }

    #goldFighter {
      grid-column: 4;
      grid-row: 2;
    }

    .locked {
      background: var(--bg-dark);
      color: var(--light-gray);
    }

    .lockedIcon {
      width: 128px;
    }

    #chooseItemsCenter {
      left: 0;
      width: 100%;
      text-align: center;
    }

    #chooseItemsCenter > * {
      position: static;
    }

    #chooseItemsCenter > .item {
      width: 96px;
    }

    .itemNameAndImage {
      position: static;
      width: 150px;
      display: inline-block;
    }

    #myItems {
      bottom: 128px;
      width: 256px;
      height: 96px;
    }

    #myItems > .itemSlot {
      display: inline-block;
      margin: 16px 8px;
    }

    .removable:hover {
      filter: brightness(25%);
      cursor: pointer;
    }

    #playerInfo, #gameContainer {
      top: 0;
      left: 0;
      width: 80%;
      height: 100%;
      padding: 8px;
      overflow: auto;
    }

    #game {
      top: 0;
      left: 0;
      width: 100%;
      min-width: 1300px;
      height: 100%;
      min-height: 900px;
      padding: 8px;
    }

    #timer {
      font-size: 48px;
    }

    .draggable {
      cursor: grab;
    }

    .draggable:hover {
      filter: brightness(80%);
    }

    .draggable:active {
      cursor: grabbing;
    }

    .playerEffects {
      position: static;
      height: 27px;
    }

    .playerEffects > .effect {
      border-color: white;
    }

    #p1-fastTimer, #p2-fastTimer {
      color: var(--bg-dark);
    }

    #fighter1a, #fighter2a, #fighter1b, #fighter2b {
      position: relative;
    }

    #fighter1a, #fighter2a {
      margin: 8px 0 16px;
    }

    #fighter1b, #fighter2b {
      margin-bottom: 8px;
    }

    .attack {
      animation: attack 0.4s linear;
    }

    @keyframes attack {
      0% {
        transform: translate(0);
      }
      50% {
        transform: translate(var(--attack-x), var(--attack-y));
      }
      100% {
        transform: translate(0);
      }
    }

    .otherOption {
      position: static;
      display: inline-block;
      padding: 2px 4px;
      border-radius: 2px;
      color: white;
      border: 1px solid transparent;
    }

    .otherOption.enabled {
      cursor: pointer;
    }

    .otherOption.enabled:hover {
      background: var(--bg-dark-highlight);
    }

    #instructions {
      bottom: 16px;
      color: var(--light-red);
    }

    .blink {
      animation: blink steps(2, jump-none) 1s infinite;
    }

    @keyframes blink {
      50% {
        opacity: 0;
      }
    }

    .droppable > * {
      pointer-events: none; /*Prevents a bug that causes flickering when dragging over child elements*/
    }

    .defeated {
      transition: all 1s, font-weight 0s;
      background: var(--bg-darker);
      color: var(--color-red);
      padding: 0;
      line-height: 325px;
      text-align: center;
      font-size: 64px;
      font-weight: bold;
    }

    #gameChat {
      top: 0;
      right: 0;
      width: 20%;
      height: 100%;
      border: none;
      border-left: 1px solid;
    }
  </style>
{% endblock %}

<!-- Change theme color here -->
{% block color %}green{% endblock %}

<!-- Extra javascript here -->

<!-- Main content here -->
{% block main %}
  <div id="border" class="fullScreen">
    <div id="topLeftBorder"></div>
    <div id="topRightBorder"></div>
    <div id="bottomLeftBorder"></div>
    <div id="bottomRightBorder"></div>
  </div>

  <div id="home" class="fullScreen">
    <div style="top: 16px; left: 16px;">
      <h2 id="myName"></h2>
      Total wins: <span id="myWins"></span><br>
      Win rate: <span id="myPercent"></span><br>
      Win streak: <span id="myStreak"></span><br>
      <u id="resetStats">Reset stats</u>
    </div>

    <h1 id="title" class="hCentered" style="top: 128px;">Turn-Based Fighter</h1>

    <div id="findMatch" class="vCentered" style="left: calc(50% - 632px);">
      <div id="findMatches" title="Search again">⟳</div>
      <h2>Find a match</h2>
      <div id="matches"></div>
      <button id="joinSelectedButton" class="hCentered unselectable" style="bottom: 32px;">Go</button>
    </div>

    <div id="enterCode" class="centered">
      <h2>Enter a match code</h2>
      <input type="text" id="joinCode" class="box centered" placeholder="Six-digit code" maxlength="6" autocomplete="off"></input>
      <button id="joinButton" class="hCentered unselectable" style="bottom: 32px;">Go</button>
    </div>

    <div id="createMatch" class="vCentered" style="right: calc(50% - 632px);">
      <h2>Create a match</h2>
      <div class="centered"><input type="checkbox" id="chatCheckbox" checked>
        <label for="chatCheckbox">Make the match public and send a link in the chat</label></div>
      <button id="createMatchButton" class="hCentered" style="bottom: 32px;">Go</button>
    </div>

    <div class="large hCentered" style="bottom: 24px;">Created by Oley Birkeland</div>
  </div>

  <div id="chooseFighters" class="fullScreen hidden">
    <button id="backToHome" class="backButton">🡨 Back</button>

    <div class="large hCentered" style="top: 16px;">
      Choose two fighters to take into the match.<br>
      <button id="randomButton"><img src="{{ url_for('static', filename='img/fighter/random.png') }}" class="randomIcon" draggable="false"> Random</button>
    </div>
    <div id="fighterOptions" class="vCentered">
      <div id="redFighter"></div>
      <div id="yellowFighter"></div>
      <div id="greenFighter"></div>
      <div id="blueFighter"></div>
      <div id="orangeFighter"></div>
      <div id="magentaFighter"></div>
      <div id="grayFighter"></div>
      <div id="goldFighter"></div>
    </div>
    <button id="fightersDone" class="hCentered unselectable" style="bottom: 32px;">Done</button>
  </div>

  <div id="chooseItems" class="fullScreen hidden">
    <button  id="backToFighters" class="backButton">🡨 Back</button>

    <div class="large hCentered" style="top: 192px; width: 100%;">Choose up to three items to take into the match. You can pick the same item more than once.</div>
    <div id="chooseItemsCenter" class="vCentered">
      <div id="itemOptions"></div><br>
      <div id="itemDesc" style="height: 21px;"></div>
    </div>

    <div id="myItems" class="items hCentered">
      <div id="myItemSlot0" class="itemSlot"><img src="{{ url_for('static', filename='img/fighter/questionMark.png') }}" id="myItem0" class="item" draggable="false"></div
      ><div id="myItemSlot1" class="itemSlot"><img src="{{ url_for('static', filename='img/fighter/questionMark.png') }}" id="myItem1" class="item" draggable="false"></div
      ><div id="myItemSlot2" class="itemSlot"><img src="{{ url_for('static', filename='img/fighter/questionMark.png') }}" id="myItem2" class="item" draggable="false"></div>
    </div>

    <button id="itemsDone" class="hCentered" style="bottom: 32px;">Done</button>
  </div>

  <div id="waiting" class="fullScreen hidden">
    <div class="hCentered" style="top: 25%;">
      <h1 id="opponentStatus" style="position: static;">Waiting for opponent…</h1>
      <h2 style="font-weight: normal;">Your match code is <b id="matchCode"></b></h2>
    </div>
    <div id="tip" class="large hCentered" style="bottom: 32px;"></div>
  </div>

  <h1 id="starting" class="centered hidden">Starting match…</h1>

  <div id="playerInfo" class="hidden">
    <div>
      <h2 id="p1-name"></h2>
      Total wins: <span id="p1-wins"></span><br>
      Win rate: <span id="p1-percent"></span><br>
      Win streak: <span id="p1-streak"></span>
    </div>

    <div style="top: 8px; right: 8px; text-align: right;">
      <h2 id="p2-name"></h2>
      Total wins: <span id="p2-wins"></span><br>
      Win rate: <span id="p2-percent"></span><br>
      Win streak: <span id="p2-streak"></span>
    </div>
  </div>

  <div id="gameContainer" class="hidden">
    <div id="game">
      <div class="hCentered">
        <h2 id="turn"></h2>
        <span id="timer"></span>
      </div>

      <div id="p1-items" class="items vertical vCentered" style="left: 32px;">
        <div id="p1-itemSlot0" class="itemSlot filled"><img id="p1-item0" class="item" draggable="false"></div>
        <div id="p1-itemSlot1" class="itemSlot filled"><img id="p1-item1" class="item" draggable="false"></div>
        <div id="p1-itemSlot2" class="itemSlot filled"><img id="p1-item2" class="item" draggable="false"></div>
      </div>

      <div class="vCentered" style="left: 160px;">
        <div id="p1-effects" class="playerEffects"></div>
        <div id="fighter1a"></div>
        <div id="fighter1b"></div>
        <div id="p1-doNothing" class="otherOption">Do nothing</div> | <div id="p1-giveUp" class="otherOption">Give up</div>
      </div>

      <div class="vCentered" style="right: 160px;">
        <div id="p2-effects" class="playerEffects"></div>
        <div id="fighter2a"></div>
        <div id="fighter2b"></div>
        <div style="position: static; text-align: right;">
          <div id="p2-doNothing" class="otherOption">Do nothing</div> | <div id="p2-giveUp" class="otherOption">Give up</div>
        </div>
      </div>

      <div id="p2-items" class="items vertical vCentered" style="right: 32px;">
        <div id="p2-itemSlot0" class="itemSlot filled"><img id="p2-item0" class="item" draggable="false"></div>
        <div id="p2-itemSlot1" class="itemSlot filled"><img id="p2-item1" class="item" draggable="false"></div>
        <div id="p2-itemSlot2" class="itemSlot filled"><img id="p2-item2" class="item" draggable="false"></div>
      </div>

      <div id="instructions" class="large hCentered"></div>
    </div>
  </div>

  <iframe id="gameChat" class="hidden"></iframe>

  <div id="matchOver" class="vCentered hidden" style="left: 0; width: calc(100% - 452px); text-align: center;">
    <h1 id="result"></h1><br>
    <button id="rematchButton">Rematch?</button>
    <button style="margin-left: 16px; color: white;" onclick="window.location = '/games/fighter';">Home</button>
  </div>
{% endblock %}
{% block script %}
  <script>
    //Comments beginning with "TO DO" indicate parts of the code that need to be worked on.

    {
      let red = {
        color: "red",
        effective: "yellow",
        weak: "blue",
        moves: {
          main: {
            damage: 14,
            doubleTarget: true,
            description: "Deals [damage] damage to both opponent fighters."
          },
          special: {
            charge: 1,
            minDamage: 45,
            maxDamage: 65,
            description: "Deals at least [minDamage] and up to [maxDamage] damage."
          },
          other: {
            type: "revenge",
            revengeDuration: 2,
            selfTarget: true,
            description: "Opponents will take 50% of the damage they inflict on this fighter. Lasts for 2 turns."
          }
        }
      };

      let yellow = {
        color: "yellow",
        effective: "green",
        weak: "red",
        moves: {
          main: {
            damage: 20,
            critDamage: 40,
            critChance: 10,
            description: "Deals [damage] damage. 10% chance of a critical hit, which deals [critDamage] damage."
          },
          alt: {
            damage: 7,
            doubleTarget: true,
            healing: true,
            description: "Deals [damage] damage to both opponent fighters. Dealt damage is added to this fighter's HP."
          },
          other: {
            type: "sacrifice",
            selfTarget: true,
            description: "Sacrifice this fighter. Teammate's attack power increases by 1% for each remaining HP."
          }
        }
      };

      let green = {
        color: "green",
        effective: "blue",
        weak: "yellow",
        moves: {
          main: {
            damage: 24,
            description: "Deals [damage] damage."
          },
          alt: {
            damage: 21,
            stunChance: 25,
            stunDuration: 1,
            description: "Deals [damage] damage. 25% chance of stunning target for 1 turn."
          },
          special: {
            charge: 2,
            damage: 78,
            description: "Deals [damage] damage."
          }
        }
      };

      let blue = {
        color: "blue",
        effective: "red",
        weak: "green",
        moves: {
          main: {
            damage: 16,
            poisonChance: 100,
            poisonDuration: 3,
            description: "Deals [damage] damage, then 5 damage per turn for the next 3 turns."
          },
          special: {
            charge: 1,
            damage: 50,
            secondaryTarget: true,
            secondaryDamage: 15,
            combinedDamage: 60,
            description: "Deals [damage] damage to target and [secondaryDamage] to other fighter. If one opponent fighter is already defeated, deals [combinedDamage] damage."
          },
          other: {
            disorientChance: 100,
            disorientDuration: 2,
            description: "Target's attacks have a 40% chance of missing. Lasts for 2 turns."
          }
        }
      };

      let orange = {
        unlockWins: 3,
        color: "orange",
        effective: "magenta",
        weak: "gold",
        moves: {
          main: {
            damage: 23,
            ignoreShield: true,
            ignoreRevenge: true,
            description: "Deals [damage] damage. Ignores \"shield\" and \"revenge\" effects."
          },
          special: {
            charge: 1,
            damage: 59,
            autoTarget: true,
            description: "Deals [damage] damage to the opponent fighter with the most HP."
          },
          other: {
            type: "addItem",
            selfTarget: true,
            description: "Adds 1 item to your inventory. You can hold up to 3 items at a time."
          }
        }
      };

      let magenta = {
        unlockWins: 8,
        color: "magenta",
        effective: "gray",
        weak: "orange",
        moves: {
          main: {
            damage: 18,
            poisonChance: 45,
            poisonDuration: 3,
            disorientChance: 30,
            disorientDuration: 2,
            stunChance: 15,
            stunDuration: 1,
            description: "Deals [damage] damage. 45% chance of poisoning target for 3 turns, 30% chance of disorienting target for 2 turns, and 15% chance of stunning target for 1 turn."
          },
          alt: {
            damage: 25,
            description: "Deals [damage] damage."
          },
          other: {
            type: "revive",
            selfTarget: true,
            description: "Revives a defeated teammate with 1 HP. Can only be used once."
          },
        }
      };

      let gray = {
        unlockWins: 15,
        color: "gray",
        effective: "gold",
        weak: "magenta",
        moves: {
          main: {
            minDamage: 10,
            maxDamage: 50,
            description: "Deals at least [minDamage] and up to [maxDamage] damage."
          },
          alt: {
            damage: 19,
            doubleTarget: true,
            teamDamage: 6,
            description: "Deals [damage] damage to each opponent fighter and [teamDamage] damage to each fighter on your own team."
          },
          special: {
            charge: 3,
            damage: 91,
            stunChance: 100,
            stunDuration: 2,
            description: "Deals [damage] damage and stuns the target for 2 turns."
          },
        }
      };

      let gold = {
        unlockStreak: 5,
        color: "gold",
        effective: "orange",
        weak: "gray",
        moves: {
          main: {
            damage: 21,
            critDamage: 63,
            critChance: 4,
            description: "Deals [damage] damage. 4% chance of a critical hit, which deals [critDamage] damage."
          },
          alt: {
            type: "copyMove",
            doubleTarget: true,
            description: "Use any opponent fighter's move."
          },
          other: {
            type: "effectRevenge",
            effectRevengeDuration: 3,
            selfTarget: true,
            description: "Opponents will gain any negative effects they give to you or your teammate. Lasts for 3 turns."
          },
        }
      };

      let items = {
        heal: {
          name: "heal",
          description: "Increases one fighter\'s HP by 30."
        },
        attackBoost: {
          name: "attack boost",
          description: "One fighter deals 50% more damage for 3 turns.",
          duration: 3
        },
        fastTimer: {
          name: "fast timer",
          description: "Speeds up opponent\'s timer for 3 turns.",
          duration: 3
        },
        skipTurn: {
          name: "skip turn",
          description: "Opponent can\'t do anything for 1 turn.",
          duration: 1
        },
        shield: {
          name: "shield",
          description: "One fighter takes 50% less damage from attacks for 3 turns.",
          duration: 3
        },
        noItems: {
          name: "no items",
          description: "Opponent can\'t use any items for 2 turns.",
          duration: 2
        },
        cleanse: {
          name: "cleanse",
          description: "Removes all negative effects from you and your fighters."
        }
      };

      let effects = {
        fastTimer: {
          name: "Fast timer",
          type: "player",
          description: "Your time will run out more quickly.",
          color: "yellow"
        },
        skipTurn: {
          name: "Skip turn",
          type: "player",
          description: "Your next turn will be skipped.",
          color: "green"
        },
        noItems: {
          name: "No items",
          type: "player",
          description: "You can't use any items.",
          color: "blue"
        },
        attackBoost: {
          name: "Attack boost",
          type: "fighter",
          description: "Attack power raised by 50%.",
          color: "orange"
        },
        shield: {
          name: "Shield",
          type: "fighter",
          description: "Reduces damage taken from attacks by 50%.",
          color: "cyan"
        },
        revenge: {
          name: "Revenge",
          type: "fighter",
          description: "Opponents will take 50% of the damage they inflict on this fighter.",
          color: "red"
        },
        effectRevenge: {
          name: "Effect revenge",
          type: "fighter",
          description: "Opponents will gain any negative effects they give to this fighter.",
          color: "gold"
        },
        poison: {
          name: "Poison",
          type: "fighter",
          description: "Take 5 damage per turn.",
          color: "purple"
        },
        disoriented: {
          name: "Disoriented",
          type: "fighter",
          description: "Attacks have a 40% chance of missing.",
          color: "pink"
        },
        stunned: {
          name: "Stunned",
          type: "fighter",
          description: "Can't use this fighter.",
          color: "brown"
        }
      };

      let fighter1a = {
        team: 1,
        name: "1a",
      };

      let fighter1b = {
        team: 1,
        name: "1b",
      };

      let fighter2a = {
        team: 2,
        name: "2a",
      };

      let fighter2b = {
        team: 2,
        name: "2b",
      };

      let me = {
        name: "{{ username }}",
        defeated: [],
        colors: [],
        items: [],
        effects: {},
        wins: {{ wins }},
        losses: {{ losses }},
        winStreak: {{ winStreak }},
        goldUnlocked: {{ goldUnlocked }}
      };

      let colors = [red, yellow, green, blue];
      let lockedColors = [orange, magenta, gray, gold];
      let fighters = [];
      let defeated = [];
      let damageProperties = ["damage", "minDamage", "maxDamage", "critDamage", "secondaryDamage", "combinedDamage", "teamDamage"];

      let match;
      let matchCode;
      let itemsArr = [];
      let opponent = {};
      let player1;
      let player2;
      let players = [];
      let active;
      let inactive;
      let countdown;
      let time;
      let winnerOverride;
      let matchOver;

      let joinCode = urlParams.get("match");
      let rematchCode = urlParams.get("rematch");
      if (joinCode) joinMatch(joinCode);
      else if (rematchCode) rematch();
      else {
        document.getElementById("myName").innerText = me.name;
        updateStats();
        document.getElementById("joinCode").onkeydown = function() {if (event.keyCode == 13) joinMatch(this.value);}; //Execute joinMatch() when enter key pressed
      }

      function capitalize(string) {
        return string[0].toUpperCase() + string.slice(1);
      }

      function pickRandom(max) {
        return Math.floor(Math.random() * max);
      }

      document.getElementById("resetStats").onclick = () => window.location = "/games/fighter?action=resetStats";
      document.getElementById("createMatchButton").onclick = createMatch;
      document.getElementById("backToHome").onclick = backToHome;
      document.getElementById("randomButton").onclick = randomFighters;
      document.getElementById("backToFighters").onclick = backToFighters;
      document.getElementById("myItemSlot0").onclick = () => removeItem(0);
      document.getElementById("myItemSlot1").onclick = () => removeItem(1);
      document.getElementById("myItemSlot2").onclick = () => removeItem(2);
      document.getElementById("rematchButton").onclick = rematchButton;

      function getTeammate(fighter) {
        if (player1.fighters.includes(fighter)) player = player1;
        else player = player2;
        let teammate = player.fighters.filter(playerFighter => playerFighter != fighter); //Get array of player's fighters and remove one
        return teammate[0]; //Return only item of new array
      }

      function sendPlayerReady() {
        let sendObj = {
          to: opponent.name,
          from: me.name,
          content: {
            type: "player",
            match: matchCode,
            player: me
          },
        }
        chatSocket.emit("fighter", JSON.stringify(sendObj));

        console.log("Player info sent:");
        console.log(sendObj);
      }

      function sendMessage(content, recipient = opponent.name) {
        let messageObj = {
          type: "message",
          to: recipient,
          from: "server",
          time: Date.now(),
          content: content
        };
        chatSocket.emit("message", JSON.stringify(messageObj));
        if (recipient != "all") { //If message is private, send to sender in addition to recipient
          messageObj.to = me.name;
          chatSocket.emit("message", JSON.stringify(messageObj));
        }
      }

      function sendMove(moveObj) {
        disableFightersAndItems();

        let sendObj = {
          to: opponent.name,
          from: me.name,
          content: {
            match: matchCode,
            type: "move",
            move: moveObj
          }
        };
        chatSocket.emit("fighter", JSON.stringify(sendObj));

        console.log("Move sent:");
        console.log(sendObj);
      }

      chatSocket.on("fighter", message => {
        let data = JSON.parse(message);
        if (data.content.match == matchCode) { //Only receive if sent from current match
          if (data.content.type == "join" && data.from != me.name) document.getElementById("opponentStatus").innerText = "Opponent is getting ready…";
          if (data.content.type == "player" && data.from != me.name) receivePlayerReady(data.content.player);
          if (data.content.type == "move") receiveMove(data.content.move);
          else if (data.content.type == "item") receiveItem(data.content);
          else if (data.content.type == "rematch" && players.every(player => player.rematch) && me.team == 1) window.location = "/games/fighter?rematch=" + matchCode;
        }
      });

      function findMatches() {
        document.getElementById("matches").innerHTML = null;
        document.getElementById("joinSelectedButton").classList.add("unselectable");
        document.getElementById("joinSelectedButton").onclick = null;
        request.open("GET", '/api/fightermatches', false);
        request.send(null);
        let res = JSON.parse(request.responseText);
        let matches = Object.keys(res).sort(() => Math.random() - 0.5) //Randomize
        matches = matches.filter(match => res[match].public == "true" && !res[match].opponent && res[match].creator != me.name).slice(0, 6); //Get available matches and keep first 6
        if (!matches.length) document.getElementById("findMatch").innerHTML += `<h3 class="centered">No matches found</h3>`;
        matches.forEach(match => {
          let matchEl = document.createElement("div");
          matchEl.id = "match" + match;
          matchEl.classList.add("match");
          matchEl.innerHTML = `<b>${res[match].creator}</b> <span style="filter: opacity(75%);">${match}</span>`;
          matchEl.onclick = function() {
            Array.from(document.querySelectorAll(".match")).forEach(el => el.classList.remove("pressed")); //Deselect all matches
            this.classList.add("pressed");
            document.getElementById("joinSelectedButton").classList.remove("unselectable");
            document.getElementById("joinSelectedButton").onclick = () => joinMatch(match);
          };
          document.getElementById("matches").append(matchEl);
        });
      }
      findMatches();
      document.getElementById("findMatches").onclick = findMatches;

      document.getElementById("joinCode").oninput = function() {
        for (let char of this.value) if (/\D/.test(char)) this.value = this.value.replace(char, ""); //Only allow numbers
        if (this.value.length == 6) {
          document.getElementById("joinButton").classList.remove("unselectable");
          document.getElementById("joinButton").onclick = () => joinMatch(document.getElementById('joinCode').value);
        } else {
          document.getElementById("joinButton").classList.add("unselectable");
          document.getElementById("joinButton").onclick = null;
        }
      };

      function updateStats() {
        if (opponent.name) { //Do this if in a match
          let p1Percent = Math.round(player1.wins / (player1.wins + player1.losses) * 100);
          p1Percent = (p1Percent || 0) + "%"; //If NaN, set to 0
          let p2Percent = Math.round(player2.wins / (player2.wins + player2.losses) * 100);
          p2Percent = (p2Percent || 0) + "%";
          document.getElementById("p1-wins").innerText = player1.wins;
          document.getElementById("p1-percent").innerText = p1Percent;
          document.getElementById("p1-streak").innerText = player1.winStreak;
          document.getElementById("p2-wins").innerText = player2.wins;
          document.getElementById("p2-percent").innerText = p2Percent;
          document.getElementById("p2-streak").innerText = player2.winStreak;
        } else {
          let myPercent = Math.round(me.wins / (me.wins + me.losses) * 100);
          myPercent = (myPercent || 0) + "%";
          document.getElementById("myWins").innerText = me.wins;
          document.getElementById("myPercent").innerText = myPercent;
          document.getElementById("myStreak").innerText = me.winStreak;
        }

        let request1 = new XMLHttpRequest();
        request1.open("POST", "/updateuser?field=fighterWins&value=" + me.wins);
        request1.send();

        let request2 = new XMLHttpRequest();
        request2.open("POST", "/updateuser?field=fighterLosses&value=" + me.losses);
        request2.send();

        let request3 = new XMLHttpRequest();
        request3.open("POST", "/updateuser?field=fighterWinStreak&value=" + me.winStreak);
        request3.send();

        if (me.winStreak == gold.unlockStreak) {
          let request4 = new XMLHttpRequest();
          request4.open("POST", "/updateuser?field=goldUnlocked&value=1");
          request4.send();
        }
      }

      if ("{{ action }}" == "resetStats" && "{{ authenticated }}" == "True") {
        me.wins = 0;
        me.losses = 0;
        me.winStreak = 0;
        me.goldUnlocked = 0;
        request.open("POST", "/updateuser?field=goldUnlocked&value=0");
        request.send();
        updateStats();
        window.location = "/games/fighter";
      }

      function joinMatch(code) {
        request.open("GET", '/api/fightermatches', false);
        request.send(null);
        let res = JSON.parse(request.responseText);
        match = res[code];
        if (!match) {
          alert("Match does not exist.");
        } else if (match.opponent) {
          alert("Match is already full.");
        } else if (match.creator == me.name) {
          alert("You can't join your own match.");
        } else {
          me.team = 2;
          me.fighters = [fighter2a, fighter2b];
          opponent.name = match.creator;
          matchCode = code;
          chatSocket.emit("fighter", JSON.stringify({
            to: opponent.name,
            from: me.name,
            content: {
              type: "join",
              match: code
            }
          }));
          request.open("POST", "/addfighteropponent?code=" + code + "&name=" + me.name);
          request.send();
          fighterOptions();
        }
      }

      function rematch() {
        //The code for rematches needs to be redone

        /*me.team = 1;
        //get match
        opponent.name = match.creator;
        fighterOptions();*/
      }

      function createMatch() {
        //Give this match a six-digit ID
        matchCode = pickRandom(1_000_000).toString().padStart(6, "0");
        me.team = 1;
        me.fighters = [fighter1a, fighter1b];
        me.firstMove = !pickRandom(2); //Decide which player goes first

        //TO DO: This doesn't work. You may be able to use Flask-SocketIO to see when someone disconnects.
        window.onunload = () => {
          request.open("POST", "/removefightermatch?code=" + matchCode);
          request.send();
        }

        fighterOptions();
      }

      function fighterOptions() {
        document.getElementById("home").classList.add("hidden");
        document.getElementById("chooseFighters").classList.remove("hidden");

        lockedColors.forEach((color) => {
          if ((color.unlockWins && me.wins >= color.unlockWins) || (color.color == "gold" && me.goldUnlocked)) { //If player has enough wins to unlock or already unlocked
            colors.push(color);
            lockedColors = lockedColors.filter(locked => locked != color);
          } else {
            let el = document.getElementById(color.color + "Fighter");
            let lockedMessage;
            if (color.unlockWins) lockedMessage = color.unlockWins + " wins to unlock";
            else lockedMessage = color.unlockStreak + "-win streak to unlock";
            el.classList.add("fighter", "locked");
            el.innerHTML = `<div class="vCentered" style="left: 0; width: 100%; text-align: center;">
              <img src="{{ url_for('static', filename='img/fighter/locked.png') }}" class="lockedIcon" draggable="false"><br><br>
              <h2>${lockedMessage}</h2>
            </div>`;
          }
        });

        colors.forEach(color => {
          let el = document.getElementById(color.color + "Fighter");
          color.hp = 100;
          createFighter(color, el);
          unchooseFighter(color);
          el.classList.add("targetOption");
          el.onclick = () => {chooseFighter(color);};
        });

      }

      function backToHome() {
        document.getElementById("chooseFighters").classList.add("hidden");
        document.getElementById("home").classList.remove("hidden");
      }

      function createFighter(fighter, fighterEl) {
        let fighterId;
        let fighterEffects = "";
        if (colors.includes(fighter)) fighterId = fighter.color;
        else fighterId = fighter.name;
        fighterEl.classList.add("fighter", fighter.color + "Bg");
        fighter.attackFactor = 1;
        fighter.effects = {};
        for (let effect in effects) {
          let effectObj = effects[effect];
          if (effectObj.type == "fighter") fighterEffects += `<div id="${fighterId}-${effect}" class="effect hidden" style="background: var(--color-${effectObj.color})">${effectObj.name}</div> `;
        }
        fighterEl.innerHTML = `<h3 id="${fighterId}-name">${capitalize(fighter.color)}</h3>
        <div class="fighterEffects">
          ${fighterEffects}
          <div id="${fighterId}-allEffects" class="effect hidden" style="background: var(--dark-gray)">2</div>
        </div>
        Effective against ${fighter.effective}, weak against ${fighter.weak}
        <div id="${fighterId}-HPBar" class="HPBar"></div><span id="${fighterId}-HPNum">${fighter.hp}</span> HP <span id="${fighterId}-HPNumChange" style="opacity: 0;"></span><br>`;
        fillHPBar(fighter, document.getElementById(fighterId + "-HPBar"));
        for (let move in fighter.moves) {
          let moveObj = fighter.moves[move];
          let moveCharge = "";
          let description = moveObj.description;
          if (move == "other") moveObj.name = move + " move";
          else moveObj.name = move + " attack";
          moveObj.id = move;
          moveObj.charged = 0;
          if (moveObj.charge) {
            if (moveObj.charge == 1) moveCharge = "<b>Charge:</b> 1 turn ";
            else moveCharge = `<b>Charge:</b> ${moveObj.charge} turns `;
            for (let i = 0; i < moveObj.charge; i++) moveCharge += `<div id="${fighterId}-${move}-cs${i + 1}" class="chargeSquare"></div>`;
            moveCharge += "<br>";
          }
          damageProperties.forEach(property => description = description.replace("[" + property + "]", `<span id=${fighterId}-${move}-${property}>${moveObj[property]}</span>`)); //Replace placeholders
          fighterEl.innerHTML += `<div id="${fighterId}-${move}" class="move">
            <h4>${capitalize(moveObj.name)}</h4>
            <span id="${fighterId}-${move}-charge">${moveCharge}</span>
            ${description}
          </div>`;
        }
        if (!colors.includes(fighter)) {
          for (let move in fighter.moves) { //This only works if it's in a separate for loop
            let moveObj = fighter.moves[move];
            moveObj.el = document.getElementById(fighter.name + "-" + move);
          }
        }
      }

      function fillHPBar(fighter, el) {
        let barColor = "green";
        if (fighter.hp < 10) barColor = "red";
        else if (fighter.hp < 25) barColor = "orange";
        else if (fighter.hp < 50) barColor = "yellow";
        el.style.background = `linear-gradient(to left, var(--color-${barColor}) 0 ${fighter.hp}%, var(--bg-dark) ${fighter.hp}% 100%)`;
      }

      function randomFighters() {
        colors.forEach(color => unchooseFighter(color));
        while (me.colors.length < 2) {
          let random = pickRandom(colors.length);
          chooseFighter(colors[random]);
        }
      }

      function chooseFighter(color) {
        let chosenEl = document.getElementById(color.color + "Fighter");
        chosenEl.style.filter = "drop-shadow(0 0 6px white)";
        me.colors.push(color);
        me.colors = colors.filter(color => me.colors.includes(color)); //Removes duplicates and puts in correct order
        chosenEl.onclick = () => unchooseFighter(color);

        if (me.colors.length == 2) {
          let buttonEl = document.getElementById("fightersDone");
          //Make all fighters unselectable
          colors.forEach(fighter => {
            let fighterEl = document.getElementById(fighter.color + "Fighter");
            if (!me.colors.includes(fighter)) {
              fighterEl.classList.remove("targetOption");
              fighterEl.classList.add("unselectable");
              fighterEl.onclick = null;
            }
          });
          buttonEl.classList.remove("unselectable");
          buttonEl.onclick = () => itemOptions();
        }
      }

      function unchooseFighter(color) {
        let chosenEl = document.getElementById(color.color + "Fighter");
        chosenEl.style.filter = null;
        me.colors.splice(me.colors.indexOf(color), 1);

        //Make all fighters selectable
        colors.forEach(fighter => {
          let fighterEl = document.getElementById(fighter.color + "Fighter");
          fighterEl.classList.remove("unselectable");
          fighterEl.classList.add("targetOption");
          if (!me.colors.includes(fighter)) fighterEl.onclick = () => chooseFighter(fighter);
        });

        let buttonEl = document.getElementById("fightersDone");
        buttonEl.classList.add("unselectable");
        buttonEl.onclick = null;
      }

      function itemOptions() {
        document.getElementById("chooseFighters").classList.add("hidden");
        document.getElementById("chooseItems").classList.remove("hidden");
        document.getElementById("itemsDone").onclick = () => itemsDone();

        removeItem(2);
        removeItem(1);
        removeItem(0);

        for (let item in items) itemsArr.push(item);
        //Add items unless they are already there
        if (!document.getElementById("itemOptions").innerHTML) {
          itemsArr.forEach(item => {
            let itemObj = items[item];
            document.getElementById("itemOptions").innerHTML +=
            `<div class="itemNameAndImage">
              <h3>${capitalize(itemObj.name)}</h3><br>
              <img id="${item}" class="item targetOption" src="/static/img/fighter/${item}.png" draggable="false">
            </div>`;
          });
          itemsArr.forEach(item => {
            let el = document.getElementById(item);
            el.onmouseover = () => document.getElementById("itemDesc").innerText = items[item].description;
            el.onmouseout = () => document.getElementById("itemDesc").innerText = null;
            el.onclick = () => chooseItem(item);
          });
        }
      }

      function backToFighters() {
        document.getElementById("chooseItems").classList.add("hidden");
        document.getElementById("chooseFighters").classList.remove("hidden");
      }

      function chooseItem(item) {
        me.items.push(item);
        displayChosenItems();
        if (me.items.length == 3) itemsArr.forEach((item) => { //Make all items unselectable
          let optionEl = document.getElementById(item);
          document.getElementById("itemDesc").innerText = null;
          optionEl.classList.remove("targetOption");
          optionEl.classList.add("unselectable");
          optionEl.onmouseover = null;
          optionEl.onclick = null;
        });
      }

      function removeItem(slot) {
        me.items.splice(slot, 1);
        displayChosenItems();
        //Make all items selectable
        itemsArr.forEach((item) => {
          let itemObj = items[item];
          let optionEl = document.getElementById(item);
          optionEl.classList.remove("unselectable");
          optionEl.classList.add("targetOption");
          optionEl.onmouseover = () => document.getElementById("itemDesc").innerText = itemObj.description;
          optionEl.onclick = () => chooseItem(item);
        });
      }

      function displayChosenItems() {
        for (let i = 0; i < 3; i++) {
          let slotEl = document.getElementById("myItemSlot" + i);
          let imgEl = document.getElementById("myItem" + i);
          if (me.items[i]) {
            imgEl.src = "/static/img/fighter/" + me.items[i] + ".png";
            imgEl.classList.add("removable");
            imgEl.title = "Remove";
            slotEl.classList.add("filled");
          } else {
            imgEl.src = "{{ url_for('static', filename='img/fighter/questionMark.png') }}";
            imgEl.classList.remove("removable");
            imgEl.removeAttribute("title");
            slotEl.classList.remove("filled");
          }
        }
      }

      function itemsDone() {
        document.getElementById("chooseItems").classList.add("hidden");

        me.fighters.forEach((fighter, i) => {
          let color = me.colors[i];
          //Copy all properties from color object to fighter object
          for (let property in color) {
            if (typeof color[property] == "object") fighter[property] = JSON.parse(JSON.stringify(color[property])); //Perform a "deep copy" so object can be modified without changing original
            else fighter[property] = color[property];
          }
        });

        while (me.items.length < 3) {
          let random = pickRandom(itemsArr.length);
          me.items.push(itemsArr[random]);
        }

        if (me.team == 1) wait();
        else {
          sendPlayerReady();
          document.getElementById("starting").classList.remove("hidden");
        }
      }

      function wait() {
        document.getElementById("waiting").classList.remove("hidden");

        document.getElementById("matchCode").innerText = matchCode;

        let public = document.getElementById("chatCheckbox").checked;

        if (public) {
          let message = `${me.name} is looking for a Fighter opponent. <button class="inline popOut" onclick="window.open('/games/fighter?match=${matchCode}');">Join match</button>`;
          sendMessage(message, "all");
        }

        if (rematchCode) sendPlayerReady();

        request.open("POST", `/createfightermatch?code=${matchCode}&name=${me.name}&public=${public}`);
        request.send();

        let tips = [
          "While in a match, look at the bottom of the screen for instructions.",
          "Pay attention to the game chat; it contains useful information.",
          "If you leave an item slot empty, you will get a random item.",
          "Using an item won't end your turn.",
          "You can't use items while charging an attack.",
          "You can hover over items and effects for more information.",
          "You will receive a loss if you leave an ongoing match.",
          //"In 2v2 mode, items are selected randomly and can be used by either teammate.",
          //"In 2v2 mode, the \"cleanse\" item affects both you and your teammate."
        ];

        let randomTip = pickRandom(tips.length);
        document.getElementById("tip").innerText = tips[randomTip];
      }

      function receivePlayerReady(player) {
        console.log("Received player:");
        console.log(player);
        opponent = player;
        if (me.team == 1) {
          fighter2a = opponent.fighters[0];
          fighter2b = opponent.fighters[1];
          sendPlayerReady();
        } else {
          fighter1a = opponent.fighters[0];
          fighter1b = opponent.fighters[1];
          opponent.firstMove ? me.firstMove = false : me.firstMove = true;
        }
        fighters = [fighter1a, fighter1b, fighter2a, fighter2b];
        fighters.forEach(fighter => fighter.el = document.getElementById("fighter" + fighter.name));

        if (me.rematch) window.location = "/games/fighter?match=" + matchCode; //Join match if you are player 2 and waiting for rematch
        startMatch();
      }

      function startMatch() {
        document.getElementById("waiting").classList.add("hidden");
        document.getElementById("starting").classList.add("hidden");
        document.getElementById("border").classList.add("hidden");
        document.getElementById("gameContainer").classList.remove("hidden");
        document.getElementById("playerInfo").classList.remove("hidden");
        document.getElementById("gameChat").classList.remove("hidden");

        window.onbeforeunload = () => true; //Show warning before leaving page

        if (me.team == 1) {
          player1 = me;
          player2 = opponent;
        } else {
          player1 = opponent;
          player2 = me;
        }

        updateStats();

        //Add a loss and reset win streak if player leaves during match
        //TO DO: This doesn't work. You may be able to use Flask-SocketIO to see when someone disconnects.
        window.onunload = () => {
          let request1 = new XMLHttpRequest();
          request1.open("POST", "/updateuser?field=fighterLosses&value=" + me.losses + 1);
          request1.send();

          let request2 = new XMLHttpRequest();
          request2.open("POST", "/updateuser?field=fighterWinStreak&value=0");
          request2.send();

          if (!matchOver) {
            sendMove({
              move: "disconnect",
              winner: opponent
            });
          }
          sendMessage(me.name + " left the match.");
        };

        players = [player1, player2];

        document.getElementById("p1-name").innerText = player1.name;
        document.getElementById("p2-name").innerText = player2.name;

        //Create player effect elements
        for (let effect in effects) {
          let effectObj = effects[effect];
          if (effectObj.type == "player") {
            document.getElementById("p1-effects").innerHTML += `<div id="p1-${effect}" class="effect hidden" style="background: var(--color-${effectObj.color})">${effectObj.name}</div> `;
            document.getElementById("p2-effects").innerHTML += `<div id="p2-${effect}" class="effect hidden" style="background: var(--color-${effectObj.color})">${effectObj.name}</div> `;
          }
        }

        fighters.forEach(fighter => {
          createFighter(fighter, fighter.el);
          for (let move in fighter.moves) {
            let moveObj = fighter.moves[move];
            if (moveObj.type == "addItem" || moveObj.type == "revive") unselectable(moveObj);
          }
        });

        //Add item images and give them titles
        me.items.forEach((item, i) => {
          let el = document.getElementById("p" + me.team + "-item" + i);
          el.src = "/static/img/fighter/" + item + ".png";
          el.title = items[item].description;
        });

        opponent.items.forEach((item, i) => {
          let el = document.getElementById("p" + opponent.team + "-item" + i);
          el.src = "/static/img/fighter/" + item + ".png";
          el.title = items[item].description;
        });

        me.firstMove ? active = me : active = opponent;

        let giveUpEl = document.getElementById("p" + me.team + "-giveUp");
        giveUpEl.classList.add("enabled");
        giveUpEl.onclick = () => {
          sendMove({
            move: "give up",
            winner: opponent
          });
          sendMessage(me.name + " forfeited the match.");
        };

        document.getElementById("gameChat").src = "/chat?game=" + opponent.name;

        startTurn();
      }

      function startTurn() {
        if (matchOver) return;

        active == me ? inactive = opponent : inactive = me;

        console.log(`${active.name}'s turn started at ${Date.now()}`);

        let activeNameEl = document.getElementById("p" + active.team + "-name");
        activeNameEl.style.color = "var(--light-red)";
        let inactiveNameEl = document.getElementById("p" + inactive.team + "-name");
        inactiveNameEl.style.color = "white";

        time = 30;
        startTimer();

        inactive.fighters.forEach(fighter => {if (fighter.effects.poison) damage(fighter, 5);}); //Deal poison damage

        //Decrease turns left for effects
        players.forEach(player => {
          for (let effect in player.effects) {
            if (player.effects[effect] == 0.5) removeEffect(effect, player);
            if (player.effects[effect]) {
              let effectEl = document.getElementById("p" + player.team + "-" + effect);
              let effectObj = effects[effect];
              player.effects[effect] -= 0.5;
              effectTitle(effect, player);
            }
          }
        });

        fighters.forEach(fighter => {
          for (let effect in fighter.effects) {
            if (fighter.effects[effect] == 0.5) removeEffect(effect, fighter);
            if (fighter.effects[effect]) {
              let effectEl = document.getElementById(fighter.name + "-" + effect);
              let effectObj = effects[effect];
              fighter.effects[effect] -= 0.5;
              effectTitle(effect, fighter);
            }
          }
        });

        if (active.effects.noItems) {
          let containerEl = document.getElementById("p" + active.team + "-items");
          containerEl.classList.add("unselectable");
        }

        if (active == me) {
          if (me.effects.skipTurn) {
            sendMove({});
            return;
          }

          me.fighters.forEach(fighter => {
            for (let move in fighter.moves) {
              if (fighter.moves[move].charged) {
                if (fighter.effects.stunned) sendMove({});
                else charge(fighter, fighter.moves[move], fighter.chargeTarget);
                return;
              }
            }
          });

          document.getElementById("turn").innerText = "Your turn";
          enableMoves(me);
          if (me.fighters.every(fighter => fighter.effects.stunned)) {
            if (me.items.some(item => item)) sendMessage("All of " + me.name + "'s available fighters are stunned. You can use the \"Do nothing\" button to skip your turn."); //Don't end turn if player has unused items
            else {
              endTurn();
              return;
            }
          }
          if (!me.effects.noItems) {
            let containerEl = document.getElementById("p" + me.team + "-items");
            containerEl.classList.remove("unselectable");
            me.items.forEach((item, i) => { //Enable items
              let itemEl = document.getElementById("p" + me.team + "-item" + i);
              let slotEl = document.getElementById("p" + me.team + "-itemSlot" + i);
              itemEl.classList.remove("unselectable");
              itemEl.draggable = true;
              itemEl.classList.add("draggable");
              itemEl.ondrag = () => pickUpItem(item, i);
              itemEl.ondragend = () => cancelItem(itemEl, slotEl);
            });
          }
          let doNothingEl = document.getElementById("p" + me.team + "-doNothing");
          doNothingEl.classList.add("enabled");
          doNothingEl.onclick = () => {
            sendMove({});
            sendMessage(me.name + " skipped their turn.");
          };
        }
        else document.getElementById("turn").innerText = "Opponent's turn";
      }

      function startTimer() {
        console.log("Timer started");
        let timerEl = document.getElementById("timer");
        let interval;
        timerEl.innerText = time;
        if (active.effects.fastTimer) {
          timerEl.style.color = "var(--light-yellow)";
          interval = 100;
        } else {
          timerEl.style.color = "white";
          interval = 1000;
        }
        if (countdown) console.error("ERROR: Tried to start the timer while it was already running.");
        clearInterval(countdown);
        countdown = setInterval(() => {
          timerEl.innerText = --time;
          if (time < 6) timerEl.style.color = "var(--light-red)";
          if (!time) {
            sendMessage(active.name + " ran out of time.");
            endTurn();
          }
        }, interval);
      }

      function effectTitle(effect, target) {
        let effectEl;
        let effectObj = effects[effect];
        let targetEffectObj = target.effects[effect];
        if (effectObj.type == "fighter") effectEl = document.getElementById(target.name + "-" + effect);
        else effectEl = document.getElementById("p" + target.team + "-" + effect);
        if (Math.round(targetEffectObj) == 1) effectEl.title = effectObj.description + " 1 turn left.";
        else effectEl.title = effectObj.description + " " + Math.round(targetEffectObj) + " turns left.";
      }

      function enableMoves(player, copySender, copyMove) {
        console.log("Enable moves");
        player.fighters.forEach(fighter => {
          for (let move in fighter.moves) {
            let moveObj = fighter.moves[move];
            if (fighter.effects.stunned || (moveObj.type == "addItem" && me.items.every(item => item)) || (moveObj.type == "revive" && me.fighters.length == 2) || (moveObj.type == "copyMove" && copySender)) unselectable(moveObj); //If move type is addItem, disable if all items are unused. If move type is revive, disable neither fighter is defeated.
            if (!moveObj.unselectable) {
              let sender = copySender || fighter;
              let clickFunction;
              moveObj.el.classList.add("enabled");
              if (moveObj.doubleTarget || moveObj.selfTarget || moveObj.autoTarget) {
                if (moveObj.charge) clickFunction = () => charge(sender, copyMove || moveObj);
                else clickFunction = () => useMove(sender, copyMove || moveObj);
              }
              else clickFunction = () => selectTarget(sender, copyMove || moveObj);
              if (copySender) moveObj.el.onclick = () => {
                for (let property in copyMove) if (property != "name" && property != "id" && property != "el") delete copyMove[property]; //Delete all properties of copyMove except "name", "id", and "el"
                for (let property in moveObj) if (property != "name" && property != "id" && property != "el") copyMove[property] = moveObj[property]; //Make copyMove a duplicate of target move
                copyMove.copied = {
                  color: fighter.color,
                  move: moveObj.name
                };
                for (let move in opponent.moves) {
                  let moveObj = fighter.moves[move];
                  moveObj.el.classList.remove("enabled");
                  moveObj.el.onclick = null;
                }
                clickFunction();
                event.stopPropagation();
              }
              else moveObj.el.onclick = () => clickFunction();
            }
          }
        });
      }

      function unselectable(move) {
        move.unselectable = true;
        move.el.classList.add("unselectable");
      }

      function removeUnselectable(move) {
        move.unselectable = false;
        move.el.classList.remove("unselectable");
      }

      function showInstructions(text) {
        let el = document.getElementById("instructions");
        el.innerText = text;
        el.classList.add("blink");
      }

      function hideInstructions() {
        let el = document.getElementById("instructions");
        el.innerText = null;
        el.classList.remove("blink");
      }

      function selectTarget(sender, move) {
        showInstructions("Select target");
        opponent.fighters.forEach(fighter => {
          fighter.el.classList.add("targetOption");
          if (move.charge) fighter.el.onclick = () => charge(sender, move, fighter);
          else fighter.el.onclick = () => useMove(sender, move, fighter);
          for (let fighterMove in fighter.moves) {
            let moveObj = fighter.moves[fighterMove];
            moveObj.el.classList.remove("enabled");
            moveObj.el.onclick = null;
          }
        });
      }

      function removeTargetOptions() {
        hideInstructions();
        fighters.forEach(fighter => {
          fighter.el.classList.remove("targetOption");
          fighter.el.onclick = null;
        });
      }

      function charge(sender, move, target) {
        if (move.charged == move.charge) { //If move is fully charged
          sender.chargeTarget = null;
          if (fighters.includes(target) || !target) useMove(sender, move, target);
          else { //If target is defeated
            sendMessage(me.name + " couldn't use " + capitalize(sender.color) + "'s " + move.name + " because the target was already defeated.");

            let sendObj = {
              type: "cancel",
              sender: sender,
              move: move
            };
            sendMove(sendObj);
          }
        } else {
          sender.chargeTarget = target;
          sendMessage(me.name + " charged " + capitalize(sender.color) + "'s " + move.name + ".");

          let sendObj = {
            type: "charge",
            sender: sender,
            move: move,
            target: target
          };
          sendMove(sendObj);
        }
      }

      function useMove(sender, move, targets = opponent.fighters) {
        let primaryTarget;
        let targetTeammate;
        let message = me.name + " used " + capitalize(sender.color) + "'s " + move.name;
        if (move.secondaryTarget) {
          primaryTarget = targets;
          targets = opponent.fighters;
        } else if (move.autoTarget) {
          //Set target to fighter with highest HP; if both fighters have same HP, choose randomly
          if (opponent.fighters.length == 1 || opponent.fighters[0].hp > opponent.fighters[1].hp) targets = opponent.fighters[0];
          else if (opponent.fighters[0].hp == opponent.fighters[1].hp) targets = opponent.fighters[pickRandom(2)];
          else targets = opponent.fighters[1];
        }
        if (!Array.isArray(targets)) targets = [targets]; //If there is only one target, turn it into an array
        if (targets.length == 1 || move.secondaryTarget) targetTeammate = getTeammate(targets[0]);
        let sendObj = {
          sender: sender,
          targets: targets,
          primaryTarget: primaryTarget,
          senderTeammate: getTeammate(sender),
          targetTeammate: targetTeammate,
          move: move,
          damage: [],
          selfDamage: 0,
          teammateDamage: 0,
          poison: [],
          disorient: [],
          stun: []
        };

        if (sender.effects.disoriented && (pickRandom(100) < 40)) message += " and missed";
        else {
          if (move.teamDamage) {
            sendObj.selfDamage += move.teamDamage * sender.attackFactor;
            sendObj.teammateDamage += move.teamDamage * sender.attackFactor;
          }
          sendObj.selfDamage = Math.round(sendObj.selfDamage);
          sendObj.teammateDamage = Math.round(sendObj.teammateDamage);
          targets.forEach((target, i) => {
            if (move.secondaryTarget) {
              if (target == primaryTarget) {
                if (fighters.includes(targetTeammate)) sendObj.damage[i] = move.damage;
                else sendObj.damage[i] = move.combinedDamage;
              }
              else sendObj.damage[i] = move.secondaryDamage;
            }
            else if (move.damage) sendObj.damage[i] = move.damage;
            else sendObj.damage[i] = pickRandom(move.maxDamage - move.minDamage + 1) + move.minDamage;

            if (move.critChance && pickRandom(100) < move.critChance) {
              sendObj.damage[i] = move.critDamage;
              message += " and got a critical hit";
            }
            sendObj.damage[i] *= sender.attackFactor;
            if (sender.effective == target.color) sendObj.damage[i] *= 1.25;
            else if (sender.weak == target.color) sendObj.damage[i] *= 0.75;
            if (target.effects.shield && !move.ignoreShield) sendObj.damage[i] /= 2;
            sendObj.damage[i] = Math.round(sendObj.damage[i]);

            if (target.effects.revenge && !move.ignoreRevenge) sendObj.selfDamage += Math.round(Math.min(sendObj.damage[i], target.hp) / 2); //Check which is lower: move's damage or target's remaining HP, then divide by 2 and set damage to sender
            if (move.healing) sendObj.selfDamage -= sendObj.damage[i];

            let messageEffects = [];

            //If random number 0–99 < percent chance of effect, add effect
            if (move.poisonChance && pickRandom(100) < move.poisonChance) {
              sendObj.poison[i] = true;
              if (move.poisonChance < 100) messageEffects.push("poisoned"); //Don't add to message if effect chance is 100 (i.e., the effect is guaranteed)
            }

            if (move.disorientChance && pickRandom(100) < move.disorientChance) {
              sendObj.disorient[i] = true;
              if (move.disorientChance < 100) messageEffects.push("disoriented");
            }

            if (move.stunChance && pickRandom(100) < move.stunChance) {
              sendObj.stun[i] = true;
              if (move.stunChance < 100) messageEffects.push("stunned");
            }

            if (messageEffects.length == 3) message += " and " + messageEffects[0] + ", " + messageEffects[1] + ", and " + messageEffects[2] + " the target";
            else if (messageEffects.length == 2) message += " and " + messageEffects[0] + " and " + messageEffects[1] + " the target";
            else if (messageEffects.length) message += " and " + messageEffects[0] + " the target";
          });
        }

        if (move.type == "addItem") {
          let random = pickRandom(itemsArr.length);
          sendObj.newItem = itemsArr[random];
        }

        if (move.type == "revive") move.used = true;

        if (move.type == "copyMove") {
          enableMoves(opponent, sender, move);
          showInstructions("Select move");
        } else {
          sendMove(sendObj);
          if (move.copied) {
            message += " to copy " + capitalize(move.copied.color) + "'s " + move.copied.move;
            //Reset move to original
            for (let property in move) if (property != "id" && property != "el") delete move[property];
            for (let property in gold.moves[move.id]) move[property] = gold.moves[move.id][property];
            document.getElementById(sender.name + "-" + move.id + "-charge").innerHTML = null;
          }
          sendMessage(message + ".");
        }
      }

      function receiveMove(data) {
        console.log("Move received:");
        console.log(data);

        if (data.move == "give up") {
          matchOver = true;
          endMatch(data.winner);
        }

        if (data.move == "disconnect") {
          matchOver = true;
          endMatch(data.winner);
          document.getElementById("rematchButton").classList.add("unselectable");
        }

        else if (data.move) {
          data.sender = fighters.find(fighter => fighter.name == data.sender.name);
          console.log(data.senderTeammate);
          data.senderTeammate &&= fighters.find(fighter => fighter.name == data.senderTeammate.name);
          if (!data.move.copied && data.sender) data.move = Object.values(data.sender.moves).find(move => move.id == data.move.id);
          else if (!data.sender) console.error("The move's sender is undefined.");

          if (inactive.fighters.includes(data.sender)) console.error("ERROR: Received a move from a player when it wasn't their turn");

          if (data.type == "charge") {
            if (data.move.copied) {
              let chargeEl = document.getElementById(data.sender.name + "-" + data.move.id + "-charge");
              if (data.move.charge == 1) chargeEl.innerHTML = "<b>Charge:</b> 1 turn ";
              else chargeEl.innerHTML = `<b>Charge:</b> ${data.move.charge} turns `;
              for (let i = 0; i < data.move.charge; i++) chargeEl.innerHTML += `<div id="${data.sender.name}-${data.move.id}-cs${i + 1}" class="chargeSquare"></div>`;
              chargeEl.innerHTML += "<br>";
            }
            let el = document.getElementById(data.sender.name + "-" + data.move.id + "-cs" + ++data.move.charged);
            try {
              el.classList.add("charged");
            } catch {
              console.error(`ERROR: Can't find element with id "${data.sender.name + "-" + data.move.id + "-cs" + data.move.charged}"`);
            }
          }

          else if (data.type == "cancel") {
            data.move.charged = 0;
            //Reset all chargeSquares
            for (let i = 1; i <= data.move.charge; i++) {
              let el = document.getElementById(data.sender.name + "-" + data.move.id + "-cs" + i);
              el.classList.remove("charged");
            }
          }

          else if (data.move.type == "revenge") addEffect("revenge", data.sender, data.move.revengeDuration);

          else if (data.move.type == "effectRevenge") active.fighters.forEach(fighter => addEffect("effectRevenge", fighter, data.move.effectRevengeDuration));

          else if (data.move.type == "sacrifice") {
            let factor = data.sender.hp / 100 + 1;
            changeAttack(data.senderTeammate, factor);
            defeat(data.sender);
          }

          else if (data.move.type == "addItem") {
            active.items.every((item, i) => {
              if (!item) { //If item already used
                let itemEl = document.getElementById("p" + data.sender.team + "-item" + i);
                let slotEl = document.getElementById("p" + data.sender.team + "-itemSlot" + i);
                active.items[i] = data.newItem;
                itemEl.src = "../../static/img/fighter/" + data.newItem + ".png";
                itemEl.classList.remove("hidden");
                slotEl.classList.add("filled");
                return;
              }
              else return true; //Move on to next item
            });
            if (active.items.every(item => item)) active.fighters.forEach(fighter => {
              for (let move in fighter.moves) {
                let moveObj = fighter.moves[move];
                if (moveObj.type == "addItem") unselectable(moveObj);
              }
            });
          }

          else if (data.move.type == "revive") {
            let revived = active.defeated[0];
            fighters.push(revived);
            defeated = fighters.filter(fighter => fighter != revived);
            active.fighters.push(revived);
            active.defeated = fighters.filter(fighter => fighter != revived);
            revived.hp = 1;
            revived.el.classList.remove("defeated");
            createFighter(revived, revived.el);
            unselectable(data.move);
          }

          else {
            data.targets.forEach((target, i) => {
              target = fighters.find(fighter => fighter.name == target.name);
              if (data.damage[i] >= target.hp && data.selfDamage >= data.sender.hp) winnerOverride = active; //If both players lose at the same time, the sender is the winner
              if (data.damage[i]) damage(target, data.damage[i]);
              if (data.poison[i]) {
                addEffect("poison", target, data.move.poisonDuration);
                if (target.effects.effectRevenge) addEffect("poison", data.sender, data.move.poisonDuration);
              }
              if (data.disorient[i]) {
                addEffect("disoriented", target, data.move.disorientDuration);
                if (target.effects.effectRevenge) addEffect("disoriented", data.sender, data.move.disorientDuration);
              }
              if (data.stun[i]) {
                addEffect("stunned", target, data.move.stunDuration);
                if (target.effects.effectRevenge) addEffect("stunned", data.sender, data.move.stunDuration);
              }
            });
            if (data.selfDamage > 0) damage(data.sender, data.selfDamage);
            else if (data.selfDamage < 0) heal(data.sender, -data.selfDamage);
            if (data.teammateDamage) damage(data.senderTeammate, data.teammateDamage);

            if (data.move.charged) {
              data.move.charged = 0;
              //Reset all chargeSquares
              for (let i = 1; i <= data.move.charge; i++) {
                let el = document.getElementById(data.sender.name + "-" + data.move.id + "-cs" + i);
                el.classList.remove("charged");
              }
            }

            //Attack animation
            let root = document.documentElement;
            if (data.sender.team == 1) root.style.setProperty("--attack-x", "4px");
            else root.style.setProperty("--attack-x", "-4px");
            if (data.targets.length == 1 && data.sender.name.includes("a") && data.targets[0].name.includes("b")) root.style.setProperty("--attack-y", "4px");
            else if (data.targets.length == 1 && data.sender.name.includes("b") && data.targets[0].name.includes("a")) root.style.setProperty("--attack-y", "-4px");
            else root.style.setProperty("--attack-y", "0");
            data.sender.el = document.getElementById("fighter" + data.sender.name);
            data.sender.el.classList.add("attack");
            setTimeout(() => data.sender.el.classList.remove("attack"), 400);
          }
        }

        endTurn();
      }

      function pickUpItem(item, slot) {
        let itemObj = items[item];
        let itemEl = document.getElementById("p" + me.team + "-item" + slot);
        let slotEl = document.getElementById("p" + me.team + "-itemSlot" + slot);
        let containerEl = document.getElementById("p" + me.team + "-items");
        removeTargetOptions();
        itemEl.classList.add("hidden");
        slotEl.classList.remove("filled");
        containerEl.ondragover = function() {itemDraggedOver(this);};
        containerEl.ondragleave = function() {this.style.filter = null;};
        containerEl.ondrop = () => cancelItem(itemEl, slotEl);
        containerEl.classList.add("droppable");
        if (["heal", "attackBoost", "shield"].includes(item)) {
          showInstructions("Drag to target");
          me.fighters.forEach(fighter => {
            let targetOption = true;
            if (item == "heal" && fighter.hp == 100) targetOption = false;
            else if (item == "attackBoost" && fighter.effects.attackBoost == itemObj.duration) targetOption = false;
            else if (item == "shield" && fighter.effects.shield == itemObj.duration) targetOption = false;
            if (targetOption) {
              fighter.el.ondragover = function() {itemDraggedOver(this);};
              fighter.el.ondragleave = function() {this.style.filter = null;};
              fighter.el.ondrop = () => useItem(item, fighter, slot, fighter);
              fighter.el.classList.add("droppable");
            }
          });
        } else {
          let target;
          if (item == "cleanse") target = me;
          else target = opponent;
          let usable = true;
          if (item == "fastTimer" && target.effects.fastTimer == itemObj.duration) usable = false;
          if (item == "skipTurn" && target.effects.skipTurn == itemObj.duration) usable = false;
          if (item == "noItems" && target.effects.noItems == itemObj.duration) usable = false;
          if (item == "cleanse" && !me.effects.fastTimer && !me.effects.noItems && !me.fighters.some(fighter => fighter.effects.poison || fighter.effects.disoriented || fighter.effects.stunned)) usable = false; //"Cleanse" item is unusable if player and all their fighters have no negative effects
          if (usable) {
            document.body.ondragover = () => event.preventDefault(); //Allow dropping
            document.body.ondrop = () => useItem(item, target, slot);
            showInstructions("Drag anywhere to use");
          }
          else document.body.ondrop = () => cancelItem(itemEl, slotEl);
        }
      }

      function itemDraggedOver(el) {
        event.preventDefault(); //Allow dropping
        el.style.filter = "drop-shadow(0 0 6px white)";
      }

      function cancelItem(itemEl, slotEl) {
        itemEl.classList.remove("hidden");
        slotEl.classList.add("filled");
        removeItemtargets();
      }

      function useItem(item, target, slot, fighter) {
        let itemObj = items[item];
        document.getElementById("p" + me.team + "-item" + slot).ondragend = null;
        if (fighter) fighter.el.style.filter = null;
        removeItemtargets();
        sendMessage(me.name + " used the \"" + itemObj.name + "\" item.");
        chatSocket.emit("fighter", JSON.stringify({
          to: opponent.name,
          from: me.name,
          content: {
            match: matchCode,
            type: "item",
            item: item,
            target: target,
            slot: slot
          }
        }));

        console.log("Item sent:");
        console.log({
          to: opponent.name,
          from: me.name,
          content: {
            match: matchCode,
            type: "item",
            item: item,
            target: target,
            slot: slot
          }
        });
      }

      function removeItemtargets() {
        let containerEl = document.getElementById("p" + me.team + "-items");
        containerEl.style.filter = null;
        containerEl.classList.remove("droppable");
        me.fighters.forEach(fighter => {
          fighter.el.ondragover = null;
          fighter.el.ondragleave = null;
          fighter.el.ondrop = null;
          fighter.el.classList.remove("droppable");
        });
        document.body.ondrop = null;
        document.body.ondragover = null;
        hideInstructions();
      }

      function receiveItem(data) {
        console.log("Item received:");
        console.log(data);

        let itemObj = items[data.item];

        data.target = fighters.find(fighter => fighter.name == data.target.name) ||
          ((me.team == data.target.team) ? me : opponent);

        if (data.item == "heal") heal(data.target, 30);
        else if (data.item == "cleanse") cleanse(data.target);
        else addEffect(data.item, data.target, itemObj.duration);
        active.items[data.slot] = null;
        document.getElementById("p" + active.team + "-item" + data.slot).classList.add("hidden");
        document.getElementById("p" + active.team + "-itemSlot" + data.slot).classList.remove("filled");
        active.fighters.forEach(fighter => {
          for (let move in fighter.moves) {
            let moveObj = fighter.moves[move];
            if (moveObj.type == "addItem") removeUnselectable(moveObj);
          }
        });
        if (active == me) enableMoves(me); //Re-enable items. If one fighter has an "add item" move, this will make it usable.
      }

      function disableFightersAndItems() {
        fighters.forEach(fighter => {
          for (let move in fighter.moves) {
            let moveObj = fighter.moves[move];
            moveObj.el.classList.remove("enabled");
            moveObj.el.onclick = null;
          }
        });
        me.items.forEach((item, i) => {
          let el = document.getElementById("p" + me.team + "-item" + i);
          el.draggable = false;
          el.classList.remove("draggable");
          el.ondrag = null;
        });
        removeTargetOptions();
      }

      function damage(target, amount) {
        let changeEl = document.getElementById(target.name + "-HPNumChange");
        try {
          changeEl.style.color = "var(--color-red)";
          changeEl.innerText = "−" + amount;
          changeEl.classList.add("showHPChange");
        } catch {
          console.error(`ERROR: Can't find element with id "${target.name + "-HPNumChange"}"`);
        }
        function decreaseHP() {
          setTimeout(() => {
            try {
              document.getElementById(target.name + "-HPNum").innerText = --target.hp;
            } catch {
              console.error(`ERROR: Can't find element with id "${target.name + "-HPNum"}"`);
            }
            fillHPBar(target, document.getElementById(target.name + "-HPBar"));
            if (!target.hp) defeat(target);
            else if (--amount) decreaseHP(); //Repeat this function until amount is 0
          }, 10);
        }
        decreaseHP();
        setTimeout(() => changeEl.classList.remove("showHPChange"), 1500);
      }

      function heal(target, amount) {
        let changeEl = document.getElementById(target.name + "-HPNumChange");
        try {
          changeEl.style.color = "var(--color-green)";
          changeEl.innerText = "+" + amount;
          changeEl.classList.add("showHPChange");
        } catch {
          console.error(`ERROR: Can't find element with id "${target.name + "-HPNumChange"}"`);
        }
        function increaseHP() {
          setTimeout(() => {
            if (target.hp < 100) {
              try {
                document.getElementById(target.name + "-HPNum").innerText = ++target.hp;
              } catch {
                console.error(`ERROR: Can't find element with id "${target.name + "-HPNum"}"`);
              }
              fillHPBar(target, document.getElementById(target.name + "-HPBar"));
              if (--amount) increaseHP(); //Repeat this function until amount is 0
            }
          }, 10);
        }
        increaseHP();
        setTimeout(() => changeEl.classList.remove("showHPChange"), 1500);
      }

      function defeat(target) {
        for (let effect in target.effects) removeEffect(effect, target);
        let targetTeammate = getTeammate(target);
        if (targetTeammate?.color == "yellow") unselectable(targetTeammate.moves.other);
        fighters.splice(fighters.indexOf(target), 1);
        defeated.push(target);
        if (target.team == me.team) {
          me.fighters.splice(me.fighters.indexOf(target), 1);
          me.defeated.push(target);
        } else {
          opponent.fighters.splice(opponent.fighters.indexOf(target), 1);
          opponent.defeated.push(target);
        }
        target.el = document.getElementById("fighter" + target.name);
        target.el.classList.add("defeated");
        target.el.innerText = "Defeated";
        let player = (target.team == me.team) ? me : opponent;
        sendMessage(player.name + "'s " + capitalize(target.color) + " defeated.");
        if (!me.fighters.length && winnerOverride != me) {
          matchOver = true;
          setTimeout(() => endMatch(opponent), 1000);
        }
        else if (!opponent.fighters.length && winnerOverride != opponent) {
          matchOver = true;
          setTimeout(() => endMatch(me), 1000);
        } else {
          for (let move in targetTeammate.moves) {
            let moveObj = targetTeammate.moves[move];
            if (moveObj.type == "revive" && !moveObj.used) removeUnselectable(moveObj);
          }
        }
      }

      function addEffect(effect, target, duration) {
        let effectEl;
        console.log("Add effect to:");
        console.log(target);
        if (effect == "attackBoost" && !target.effects.attackBoost) changeAttack(target, 1.5);
        else if (effect == "stunned") for (let move in target.moves) unselectable(target.moves[move]);
        target.effects[effect] = duration;
        if (fighters.includes(target)) effectEl = document.getElementById(target.name + "-" + effect);
        else effectEl = document.getElementById("p" + target.team + "-" + effect);
        if (Object.keys(target.effects).length > 4) { //Only possible for fighters, not players
          //Condense all effect elements into one
          let allEffectsEl = document.getElementById(target.name + "-allEffects");
          allEffectsEl.removeAttribute("title");
          let i = Object.keys(target.effects).length;
          for (let effectProperty in target.effects) {
            document.getElementById(target.name + "-" + effectProperty).classList.add("hidden");
            allEffectsEl.classList.remove("hidden");
            //List all effects in title
            allEffectsEl.title += effects[effectProperty].name;
            if (--i) allEffectsEl.title += ", ";
          }
          allEffectsEl.innerText = Object.keys(target.effects).length; //Display the total number of effects
        }
        else effectEl.classList.remove("hidden");
        effectTitle(effect, target);
      }

      function removeEffect(effect, target) {
        let effectEl;
        console.log("Remove effect from:");
        console.log(target);
        delete target.effects[effect];
        if (effect == "attackBoost") changeAttack(target, 2/3);
        else if (effect == "stunned") for (let move in target.moves) removeUnselectable(target.moves[move]);
        if (fighters.includes(target)) {
          let allEffectsEl = document.getElementById(target.name + "-allEffects")
          effectEl = document.getElementById(target.name + "-" + effect);
          let i = Object.keys(target.effects).length;
          if (Object.keys(target.effects).length <= 4) {
            for (let effectProperty in target.effects) document.getElementById(target.name + "-" + effectProperty).classList.remove("hidden");
            allEffectsEl.classList.add("hidden");
            effectEl.classList.add("hidden");
          } else {
            allEffectsEl.innerText = Object.keys(target.effects).length;
            allEffectsEl.removeAttribute("title");
            for (let effectProperty in target.effects) {
              allEffectsEl.title += effects[effectProperty].name;
              if (--i) allEffectsEl.title += ", ";
            }
          }
        }
        else {
          effectEl = document.getElementById("p" + target.team + "-" + effect);
          effectEl.classList.add("hidden");
        }
      }

      function changeAttack(target, factor) {
        target.attackFactor *= factor;
        for (let move in target.moves) {
          damageProperties.forEach(property => {
            if (target.moves[move][property]) document.getElementById(target.name + "-" + move + "-" + property).innerText = Math.round(target.moves[move][property] * target.attackFactor);
          });
        }
      }

      function cleanse(player) {
        if (player.effects.fastTimer) {
          removeEffect("fastTimer", player);
          countdown = clearInterval(countdown);
          startTimer();
        }
        removeEffect("noItems", player);
        player.fighters.forEach(fighter => {
          removeEffect("poison", fighter);
          removeEffect("disoriented", fighter);
          removeEffect("stunned", fighter);
        });
      }

      function endTurn() {
        console.log(`${active.name}'s turn ended at ${Date.now()}`);
        countdown = clearInterval(countdown);

        disableFightersAndItems();

        let doNothingEl = document.getElementById("p" + me.team + "-doNothing");
        doNothingEl.classList.remove("enabled");
        doNothingEl.onclick = null;

        if (active == me) active = opponent;
        else active = me;
        if (!matchOver) setTimeout(startTurn, 1000);
      }

      function endMatch(winner) {
        let resultEl = document.getElementById("result");

        document.getElementById("game").classList.add("hidden");
        document.getElementById("matchOver").classList.remove("hidden");

        window.onbeforeunload = null;

        document.getElementById("p1-name").style.color = "white";
        document.getElementById("p2-name").style.color = "white";

        winner = (me.team == winner.team) ? me : opponent;

        if (winner == me) {
          resultEl.innerText = "You win!";
          me.wins++;
          me.winStreak++;
          opponent.losses++;
          opponent.winStreak = 0;

          let request1 = new XMLHttpRequest();
          request1.open("POST", "/savescore?game=fighter&score=" + me.wins);
          request1.send();
        } else {
          resultEl.innerText = "You lose";
          opponent.wins++;
          opponent.winStreak++;
          me.losses++;
          me.winStreak = 0;
        }
        updateStats();

        if (me.team == 1) {
          let request2 = new XMLHttpRequest();
          request2.open("POST", "/removefightermatch?code=" + matchCode);
          request2.send();
        }
      }

      function rematchButton() {
        alert("This feature is not available yet.");
        return;
        //TO DO: If both players press this button, start a new match
        let el = document.getElementById("rematchButton");
        el.classList.add("pressed");
        el.onclick = null;
        me.rematch = true;
        chatSocket.emit("fighter", JSON.stringify({
          to: opponent.name,
          from: me.name,
          content: {
            match: matchCode,
            type: "rematch"
          }
        }));
        sendMessage(me.name + " wants to rematch.");
      }
    }
  </script>
{% endblock %}
