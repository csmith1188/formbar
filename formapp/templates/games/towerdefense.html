{% extends 'header_fullscreen.html' %}
<!-- ^^ This means add this file into the contents of the header page -->
<!-- This is where the title, top buttons, and stylesheet is located -->

<!-- Change title here -->
{% block title %}Blewnz{% endblock %}

<!-- Extra style declarations here -->
{% block style %}
<style>
  body {
    background: var(--bg-darker);
    user-select: none;
  }

  #container {
    aspect-ratio: 16 / 9;
    outline: 1px solid var(--dark-gray);
    overflow: hidden;
    text-align: left;
  }

  @media (max-aspect-ratio: 16/9) {
    #container {
      width: 100%;
      font-size: calc(5vw / 6);
    }
  }

  @media (min-aspect-ratio: 16/9) {
    #container {
      height: 100%;
      font-size: calc(40vh / 27);
    }
  }

  #game {
    position: absolute;
    width: 100%;
    background: linear-gradient(to bottom right, #040, #400, #004);
    background-size: 100%;
  }

  button:not(.inline) {
    background: transparent;
  }

  button:not(.inline):not(.unselectable):hover {
    background: #fff2;
  }

  #progress {
    position: absolute;
    left: 1.5%;
    top: calc(24% / 9);
    width: 100%;
    color: var(--light-blue);
  }

  #progressText {
    font-size: 250%;
  }

  #achievements {
    margin-top: 1%;
    font-size: 200%;
  }

  #achvButton {
    margin-left: 0.75%;
    font-size: 75%;
  }

  .complete {
    color: var(--light-yellow) !important;
  }

  .complete span,
  .complete button:not(:hover) {
    filter: drop-shadow(0 0 5px #fffa);
  }

  #back {
    position: absolute;
    left: 0%;
    top: 0;
    width: calc(75% / 16);
    height: calc(75% / 9);
    padding: 0;
    text-align: center;
    font-size: 400%;
    line-height: 130%;
    color: white;
    cursor: pointer;
  }

  #prevMap {
    position: absolute;
    left: 15%;
    top: calc(250% / 9);
    width: calc(75% / 16);
    height: calc(75% / 9);
    padding: 0;
    text-align: center;
    font-size: 400%;
    line-height: 130%;
    color: var(--light-cyan);
    cursor: pointer;
  }

  #nextMap {
    position: absolute;
    right: 15%;
    top: calc(250% / 9);
    width: calc(75% / 16);
    height: calc(75% / 9);
    padding: 0;
    text-align: center;
    font-size: 400%;
    line-height: 130%;
    color: var(--light-cyan);
    cursor: pointer;
  }

  #prevMap:active,
  #nextMap:active {
    color: white;
  }

  #difficulty {
    position: absolute;
    left: 0;
    top: 56%;
    width: 100%;
    text-align: center;
    font-size: 200%;
  }

  #normal,
  #hard {
    padding: 0.25% 1%;
    margin: 0 0.5%;
    border: 1px solid;
    border-radius: 9999px;
    font-size: calc(inherit x 0.75);
    font-weight: 500;
  }

  #normal {
    color: var(--light-green);
  }

  #normal.pressed {
    background: var(--light-green);
    border-color: var(--light-green);
    color: var(--bg-dark);
  }

  #hard {
    color: var(--light-orange);
  }

  #hard.pressed {
    background: var(--light-orange);
    border-color: var(--light-orange);
    color: var(--bg-dark);
  }

  #startButton {
    position: absolute;
    bottom: 5%;
    padding: 0.25% 1%;
    color: var(--light-cyan);
    border: 1px solid;
    border-radius: 9999px;
    font-size: 200%;
    font-weight: 500;
  }

  #grid {
    position: absolute;
    top: 0;
    width: 100%;
    aspect-ratio: 32 / 15;
    border-collapse: collapse;
  }

  table,
  td {
    border: none;
  }

  td {
    width: calc(100% / 32);
  }

  .visibleLines td {
    border: 1px solid #555;
  }

  td.gameButton {
    cursor: pointer;
  }

  td.droppable {
    background: #aaa5;
  }

  td.undroppable {
    background: #a555;
  }

  td.tower {
    cursor: pointer;
  }

  #alert {
    position: absolute;
    width: 30%;
    height: 30%;
    padding: 1.5%;
    box-sizing: border-box;
    background: #cccc;
    color: var(--bg-dark);
    font-size: 150%;
    text-align: left;
    filter: drop-shadow(10px 10px 5px black);
  }

  #alert.large {
    height: 50%;
  }

  #alert.error b {
    color: var(--color-red);
  }

  #alertText {
    position: absolute;
    top: calc(5% * 16 / 9);
    left: 5%;
    width: 90%;
    height: 50%;
    overflow: auto;
  }

  #alert.large #alertText {
    top: calc(5% * 16 / 15);
    height: 70%;
  }

  #alert h1 {
    margin: 0 0 3% 0;
    font-size: 125%;
    font-weight: normal;
  }

  li.earned::marker {
    content: "🗸  ";
  }

  #ok {
    position: absolute;
    left: 40%;
    bottom: 10%;
    width: 20%;
    height: 20%;
    padding: 0.25% 1%;
    background: white;
    color: var(--color-blue);
    border: 1px solid;
    border-radius: 9999px;
    font-size: calc(400% / 3);
    font-weight: 500;
    filter: drop-shadow(2px 2px 1px #000c);
  }

  #alert.large #ok {
    height: 12%;
    bottom: 6%;
  }

  #ok:hover {
    background: white !important;
    filter: brightness(90%) drop-shadow(2px 2px 1px #000a);
  }

  .menu {
    position: absolute;
    min-width: 15%;
    max-width: 20%;
    padding: 0.5%;
    box-sizing: border-box;
    background: #cccc;
    color: var(--bg-dark);
    text-align: center;
    filter: drop-shadow(10px 10px 5px black);
  }

  .splitButton {
    color: var(--color-green);
    border: 1px solid;
    border-radius: 4px;
    font-size: 80%;
    font-weight: 500;
    filter: drop-shadow(2px 2px 1px #000c);
  }

  .splitButton:not(.unselectable) {
    cursor: pointer;
  }

  .buttonLeft {
    width: fit-content;
    padding: 0 1.5%;
    border-radius: 4px 0 0 4px;
    background: white;
  }

  .buttonRight {
    width: fit-content;
    padding: 0 1.5%;
    border-radius: 0 4px 4px 0;
    background: var(--color-green);
    color: white;
  }

  .splitButton:not(.unselectable):hover {
    filter: brightness(90%) drop-shadow(2px 2px 1px #000a);
  }

  .sellButton {
    color: var(--color-red);
  }

  .sellButton .buttonRight {
    background: var(--color-red);
  }

  .bought .buttonLeft {
    border-radius: 4px;
  }

  .bought .buttonRight {
    display: none;
  }

  .menu h1 {
    margin: 0 0 4% 0;
    font-size: 150%;
    font-weight: normal;
  }

  .menu h2 {
    margin: 3% 0 0 0;
    font-size: 125%;
    font-weight: normal;
  }

  #towers {
    position: absolute;
    bottom: 0;
    width: 100%;
    aspect-ratio: 32 / 3;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 5%;
    background: #0005;
    border-top: 1.5px solid var(--light-gray);
    cursor: default;
  }

  #towers img {
    height: calc(100% / 3);
  }

  #towers img:not(.unselectable):hover {
    cursor: grab;
    filter: drop-shadow(0 0 6px white);
  }

  #towers img:not(.unselectable):active {
    cursor: grabbing;
  }

  #towers img.unselectable {
    opacity: 25%;
  }

  #towerDesc {
    position: absolute;
    top: 5%;
    width: 100%;
    text-align: center;
    font-size: 150%;
  }

  #powers {
    position: absolute;
    bottom: 10%;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 3%;
    text-align: center;
  }

  #powers button {
    width: 5.125%;
    padding: 0.1% 0.3%;
    font-size: 100%;
  }

  .invisible {
    visibility: hidden;
  }

  .powerReady {
    animation: powerReady 1s;
  }

  @keyframes powerReady {
    12.5% {
      transform: rotate(1deg);
    }

    37.5% {
      transform: rotate(-2deg);
    }

    50% {
      background: #fff2;
      color: white;
    }

    62.5% {
      transform: rotate(2deg);
    }

    87.5% {
      transform: rotate(-1deg);
    }
  }
</style>
{% endblock %}

<!-- Main content here -->
{% block main %}
<div id="container" class="centered">
  <canvas id="game" width="1920" height="1080"></canvas>
  <div id="progress"></div>
  <table id="grid" class="hidden"></table>
  <div id="towers" class="hidden">
    <div id="towerDesc"></div>
    <div id="powers"></div>
  </div>
</div>
{% endblock %}

<!-- Extra javascript here -->
{% block script %}
<script>
  // When the page needs to refresh, send a signal to chat which will then refresh everyone's page
  chatSocket.on("reload", message => {
    location.reload();
  });
  let pause = [10, null];

  let wavesDefault = [
    [[4, "g", pause], "g"],
    [[7, "g", "g", pause], ["alert", "All enemy types have different health and speed stats."], "y", pause, "y"],
    [[5, "g"], [3, "y"]],
    [[20, "g"]],
    [[2, "y"], [5, [3, "g"], pause], [3, "y"]],
    [[10, "y"], [4, "o", pause], "o"],
    [[6, "g", "y", "o", pause], "g", "y", "o"],
    [[9, "y"], [7, "o"]],
    [[50, "g"]],
    [["alert", "<h1>New enemy ability: <b>Healing</b></h1>Enemies with this ability gradually regain health, so you need to destroy them quickly. They're also immune to poison."], [9, "oh", pause], "oh"],
    [[7, [6, "y", pause]], [6, "y"]],
    [[20, "oh"]],
    [[15, "o", "y"]],
    [[32, "g"], pause, [16, "y"], pause, [8, "o"], pause, [4, "r"]],
    [[6, "r"], ["alert", "<h1>New enemy ability: <b>Acceleration</b></h1>Enemies with this ability move faster as they lose health. They also can't be slowed by Slowing Towers."], [10, "oa"]],
    [[5, "g", [3, "r"], "g", pause], "g", [3, "r"], "g"],
    [[8, "oa", "ra", pause], "oa", "ra"],
    [[2, [12, "r"], pause], [12, "r"]],
    [[100, "y"]],
    [[2, "b", pause], "b"],
    [["alert", "<h1>New enemy ability: <b>Split</b></h1>Enemies with this ability split into two or more weaker enemies when they run out of health, making them much harder to destroy."], "rs"],
    [[7, "y", "o", "r", pause], [12, "rh"]],
    [[4, "os"], pause, [25, "o"], "bs"],
    [[5, "p"]],
    [[3, "pa", "bh", pause], [8, "rs", pause], "rs"],
    [["alert", "<h1>New enemy ability: <b>Blink</b></h1>Enemies with this ability switch between two states: visible and hidden. Without upgrades, towers can only hit them while they're visible."], [29, "yk", pause], "yk"],
    [[250, "g"]],
    [["alert", "Boss enemies have 100 HP."], "x"],
    ["pk"],
    [[5, "bs"]],
    [[2, [35, "r"], [5, "p"]]],
    [[14, "ba"], [26, "rh"]],
    [["alert", "<h1>New enemy ability: <b>Shield</b></h1>Enemies with this ability can only be damaged by explosions, poison, and hits from Long-Range Towers."], "gd"],
    [[30, "o"], pause, "x", pause, "x"],
    [[3, "bs"], [3, "ps"]],
    [[20, "rk"], pause, [5, "bk"]],
    [[3, "bd", pause], "bd"],
    ["xs"],
    [[10, "ok"], [8, "rh"], [19, "p"], [4, "rs"]],
    [[125, "yh"], "xa", [33, "b"]],
    [[4, "x"], [45, "r"], "xk"],
    [[7, "os"], pause, [13, "pk"][64, "g"]],
    ["x", [18, "rd"], pause, "x"],
    [[85, "b", "p"]],
    [["alert", "Brown-boss enemies have 500 HP."], "z"],
    [[10, "x"], pause, [30, "bh"], [20, "r"]],
    [[3, "z", pause], [17, "ps"], [43, "ok"], [5, "x"]],
    [[15, "pk"], "xs", [3, "x", "z"], [300, "o"], "pd"],
    [[50, "ra"], [125, "bk"], pause, [67, "bh"], [999, "yk"], "z"],
    [[10, "g"], pause, [20, "y"], pause, [30, "o"], pause, [40, "r"], pause, [100, "p"], pause, [100, "b"], pause, [15, "x"], pause, [5, "z"]],

    //Hard mode only
    [[150, "bs"], [15, "bd"]],
    [[7, "x"], [80, "oa", "p"]],
    [[10, "za"]],
    [[100, "bk"], [12, "xh"], [75, "r", "pa", "os"]],
    [["alert", "Purple-boss enemies move much faster than normal bosses."], [4, "u", pause], "u"],
    [[30, "bd"], [3, "x"], pause, "xs"],
    [[150, "ra", "rh"]],
    [[3, "za"], pause, [2, "zh"], pause, "zk"],
    [[200, "ra"], "xd"],
    [[375, "p", "r", "b"], [20, "xa"]],
    [[6, "uh"], [15, "xa"]],
    [[50, "x"], pause, [10, "zh"]],
    [[8, "zk", pause], [20, "x"]],
    [[135, "bh", "rs"]],
    [[11, [17, "ra"], "z"]],
    [[14, "xa"], [15, [5, "od"], pause], [5, "z"], [5, "u"]],
    [[50, [2, "pa"], [5, "r"]], pause, [15, "za"]],
    [[5, "xd"]],
    [[60, "b"], [10, "uk"], [130, "b"]],
    ["uh", [10, [23, "rk"], "z"], [65, "ba"]],
    [[20, "u"], pause, [40, "xh"]],
    [[20, "pa"], [25, "pa", "xs"], pause, [200, "gd"], [3, "ua", "zh"]],
    [[111, "bh"], [8, "za"], [35, [9, "ph", "uk"]]],
    [[90, "b", "p"], pause, [100, "x"]],
    [[2, "zd", "ud", pause], "zd", "ud", [300, "ba"], [30, "xh"], pause, [20, "u", "uh", "ua"]]
  ];
</script>
<script src="{{ url_for('static', filename='js/tdMaps.js') }}"></script>
<script>
  {
    let towerTypes = {
      basic: {
        name: "Basic Tower",
        color: "#ccc",
        description: "A cheap tower with average stats.",
        range: 2.5,
        speed: 1,
        strength: 1,
        price: 30,
        extra1: {
          description: "Projectiles can bounce to up to three nearby enemies.",
          price: 60,
          add: function () {
            this.bounce = 3;
          }
        },
        extra2: {
          description: "Projectiles can hit up to eight enemies.",
          price: 120,
          add: function () {
            this.bounce = 8;
          }
        },
        power: {
          description: "All Basic Towers attack 5× as fast for 10 seconds.",
          price: 75,
          use: function () {
            towers.filter(tower => tower?.name == "Basic Tower").forEach(tower => tower.speedBoost = 250);
            sound.playSFX("powerUp2");
          }
        }
      },
      slowing: {
        name: "Slowing Tower",
        color: "#80ffff",
        description: "Weaker attacks, but hits slow down enemies for 10 seconds.",
        range: 1.64,
        speed: 1.92,
        strength: 0.5,
        slowing: true,
        price: 25,
        extra1: {
          description: "Enemies lose all abilities while they are slowed down.",
          price: 45,
          add: function () {
            this.abilityBlocking = true;
          }
        },
        extra2: {
          description: "Slowing affects enemies permanently.",
          price: 135,
          add: function () {
            this.permSlow = true;
          }
        },
        power: {
          description: "Stuns every onscreen enemy for 3 seconds. Stunned enemies take twice as much damage.",
          price: 60,
          use: function () {
            enemies.forEach(enemy => enemy.stunned = 75);
            sound.playSFX("powerUp2");
          }
        }
      },
      poison: {
        name: "Poison Tower",
        color: "#df80ff",
        description: "Enemies are poisoned when hit, taking 0.6 damage a second for 5 seconds.",
        range: 3.19,
        speed: 1.2,
        strength: 0.75,
        poison: true,
        price: 55,
        extra1: {
          description: "Poison can splash to a nearby enemy.",
          price: 30,
          add: function () {
            this.poisonSplash = true;
          }
        },
        extra2: {
          description: "Poisoned enemies take damage twice a second.",
          price: 40,
          add: function () {
            this.doublePoison = true;
          }
        },
        power: {
          description: "All onscreen enemies move backward for 3 seconds.",
          price: 55,
          use: function () {
            enemies.forEach(enemy => enemy.reverse = 75);
            sound.playSFX("powerUp2");
          }
        }
      },
      longRange: {
        name: "Long-Range Tower",
        color: "#ffdf40",
        description: "Infinite range and strong attacks, but fires slowly. Targets the strongest enemy onscreen.",
        range: Infinity,
        speed: 0.34,
        strength: 6,
        price: 80,
        extra1: {
          description: "Can hit blinking enemies while they are hidden.",
          price: 15,
          add: function () {
            this.seeInvisible = true;
          }
        },
        extra2: {
          description: "Enemies hit by this tower lose all abilities permanently.",
          price: 200,
          add: function () {
            this.removeAbilities = true;
          }
        },
        power: {
          description: "Does 150 damage to the strongest enemy on the screen.",
          price: 150,
          use: function () {
            let strongest = enemies.sort((a, b) => b.health - a.health)[0];
            strongest?.hit(Infinity, this);
            sound.playSFX("laser");
          }
        }
      },
      cannon: {
        name: "Cannon Tower",
        color: "#ff8f40",
        description: "Every hit creates an explosion that damages nearby enemies.",
        range: 3.4,
        speed: 0.66,
        strength: 2,
        price: 100,
        explosionSize: 100,
        extra1: {
          description: "Explosions are increased in size.",
          price: 30,
          add: function () {
            this.explosionSize = 150;
          }
        },
        extra2: {
          description: "Explosions do as much damage as direct hits.",
          price: 75,
          add: function () {
            this.powerfulExplosions = true;
          }
        },
        power: {
          description: "Creates a giant explosion at the center of the screen that does significant damage to all enemies inside of it.",
          price: 100,
          use: function () {
            //Create an explosion centered around the target enemy
            let inExplosion = enemies.filter(enemy => Math.sqrt((960 - enemy.x) ** 2 + (450 - enemy.y) ** 2) < 400);
            inExplosion.forEach(enemy => enemy.hit(25, this, "explosion")); //Do damage to every enemy inside the explosion
            //Draw the explosion as an orange circle
            ctx.strokeStyle = "transparent";
            ctx.fillStyle = "#ff8f4055";
            ctx.drawCircle(960, 450, 400);
            sound.playSFX("explode1");
          }
        }
      },
      money: {
        name: "Money Tower",
        color: "#80ff80",
        description: "Gets 3× as much money from defeating enemies.",
        range: 3.32,
        speed: 0.88,
        strength: 1.25,
        extraMoney: true,
        price: 150,
        extra1: {
          description: "Adds an extra $10 every 10 seconds.",
          price: 300,
          add: function () {
            player.bonusMoney += 10;
          }
        },
        extra2: {
          description: "Adds an extra life every 15 seconds.",
          price: 250,
          add: function () {
            player.bonusLives += 1;
          }
        },
        power: {
          description: "Adds $100 to your total.",
          price: 380,
          use: function () {
            player.money += 100;
            sound.playSFX("coin1");
          }
        }
      },
      air: {
        name: "Air Tower",
        color: "#bfcfff",
        large: true,
        description: "Moves back and forth above the track. Has a large range and attacks quickly.",
        range: 3.61,
        speed: 2.79,
        strength: 1,
        movable: true,
        price: 150,
        extra1: {
          description: "Every fifth hit creates a small explosion.",
          price: 25,
          add: function () {
            this.nextExplosion = 5;
          }
        },
        extra2: {
          description: "Whatever tower is closest to the plane will get a range boost.",
          price: 50,
          add: function () {
            this.rangeBoosting = true;
          }
        },
        power: {
          description: "A highly powerful plane will fly over the track, starting from the exit.",
          price: 300,
          use: function () {
            let initialX = map.start[0] * 60;
            let initialY = map.start[1] * 60;
            mapArr.forEach(direction => {
              switch (direction) {
                case "right":
                  initialX++;
                  break;
                case "left":
                  initialX--;
                  break;
                case "down":
                  initialY++;
                  break;
                case "up":
                  initialY--;
              }
            });
            superPlane = {
              initialX: initialX,
              initialY: initialY,
              distance: 0,
              range: 3.97,
              speed: 12.57,
              strength: 3.5
            }
          }
        }
      },
      ultimate: {
        name: "Ultimate Tower",
        color: "#ff6860",
        large: true,
        description: "Can rapidly destroy many enemies across a wide range.",
        range: 4.65,
        speed: 7.38,
        strength: 2,
        price: 400,
        extra1: {
          description: "Attack power is slightly increased for each enemy on the screen.",
          price: 135,
          add: function () {
            this.crowdBonus = true;
          }
        },
        extra2: {
          description: "Does 2.5× damage to boss enemies.",
          price: 1000,
          add: function () {
            this.bossBonus = true;
          }
        },
        power: {
          description: "All towers get double range, speed, and strength for 10 seconds.",
          price: 300,
          use: function () {
            towers.forEach(tower => {
              if (tower) tower.ultimateBoost = 250;
              sound.playSFX("powerUp2");
            });
          }
        }
      }
    };
    for (let type in towerTypes) {
      towerTypes[type].upgrades = {
        range: 0,
        speed: 0,
        strength: 0
      };

      //Create images for each tower type
      towerTypes[type].img = new Image();
      towerTypes[type].img.src = `../../static/img/towerdefense/${type}${type == "air" ? "-b" : ""}.png`;
      towerTypes[type].icon = new Image();
      towerTypes[type].icon.src = `../../static/img/towerdefense/${type}.png`;
      towerTypes[type].activeImg = new Image();
      towerTypes[type].activeImg.src = `../../static/img/towerdefense/${type}-active.png`;
    }

    let enemyTypes = {
      green: {
        speed: 1,
        health: 1
      },
      yellow: {
        speed: 1.5,
        health: 2
      },
      orange: {
        speed: 2,
        health: 3
      },
      red: {
        speed: 2.5,
        health: 4,
      },
      purple: {
        speed: 4,
        health: 2
      },
      brown: {
        speed: 1,
        health: 10
      },
      boss: {
        speed: 0.5,
        health: 100,
        boss: true
      },
      brownBoss: {
        speed: 0.25,
        health: 500,
        boss: true
      },
      purpleBoss: {
        speed: 4,
        health: 100,
        boss: true
      },
    };
    for (let type in enemyTypes) {
      enemyTypes[type].img = new Image();
      enemyTypes[type].img.src = `../../static/img/towerdefense/${type}.png`;
      if (type != "green" && type != "brownBoss" && type != "purpleBoss") {
        enemyTypes[type].imgSplit = new Image();
        enemyTypes[type].imgSplit.src = `../../static/img/towerdefense/${type}-split.png`;
      }
      if (enemyTypes[type].boss) {
        enemyTypes[type].imgRotated = new Image();
        enemyTypes[type].imgRotated.src = `../../static/img/towerdefense/${type}-r.png`;
        if (type == "boss") {
          enemyTypes[type].imgSplitRotated = new Image();
          enemyTypes[type].imgSplitRotated.src = `../../static/img/towerdefense/boss-split-r.png`;
        }
      }
    }

    class Tower {
      constructor(type, row, col) {
        for (let property in type) this[property] = type[property];
        //Make new objects so towers can be upgraded independently
        this.upgrades = Object.create(this.upgrades);
        this.extra1 = Object.create(this.extra1);
        this.extra2 = Object.create(this.extra2);
        this.value = type.price;
        //Convert the tower's position from squares to pixels
        this.x = col * 60 + 30;
        this.y = row * 60 + 30;
        if (type.name == "Air Tower") {
          //Make an array of all the squares the track goes through
          let trackSquares = [];
          grid.forEach((row, i) => row.forEach((square, j) => {
            if (square == "track") trackSquares.push([j, i]);
          }));
          //The plane will appear at the nearest track square to the tower
          let closest = trackSquares.sort((a, b) => ((col - a[0]) ** 2 + (row - a[1]) ** 2) - ((col - b[0]) ** 2 + (row - b[1]) ** 2))[0];
          this.planeStartX = map.start[0] * 60;
          this.planeStartY = map.start[1] * 60;
          switch (map.lines[0][0]) {
            case "right":
              this.planeStartX += 60;
              break;
            case "left":
              this.planeStartX -= 60;
              break;
            case "down":
              this.planeStartY += 60;
              break;
            case "up":
              this.planeStartY -= 60;
          }
          this.planeDistance = 0;
          let closestX = closest[0] * 60 + 30;
          let closestY = closest[1] * 60 + 30;
          let xPos = this.planeStartX;
          let yPos = this.planeStartY;
          //Increase the plane's distance on the track until it reaches the point closest to the tower
          for (let i = 0; xPos != closestX || yPos != closestY; i++) {
            switch (planePathArr[i]) {
              case "right":
                xPos++;
                break;
              case "left":
                xPos--;
                break;
              case "down":
                yPos++;
                break;
              case "up":
                yPos--;
            }
            this.planeDistance++;
          }
        }
        this.i = towers.length;
        this.cooldown = 0; //Time until the tower can attack again
        //Display a menu with information and upgrade buttons
        this.showMenu = function () {
          if (paused) return;
          this.menuOpen = true;

          let menu = document.createElement("div");
          menu.classList.add("menu");
          menu.innerHTML = `
              <h1>${type.name}</h1>


              <h2><span id="sell" class="splitButton sellButton">
                <span class="buttonLeft">Sell</span><span class="buttonRight">+$${this.sellValue}</span>
              </span></h2>

              <h2>
                Range: ${Math.round(this.range * 100) / 100}
                <span id="range" class="splitButton">
                  <span class="buttonLeft">${(this.upgrades.range == 2 || this.range == Infinity) ? "Max" : "→&nbsp;" + Math.round(this.range * 1.25 * 100) / 100}</span><span class="buttonRight">$${this.upgradePrice("range")}</span>
                </span>
              </h2>

              <h2>
                Speed: ${Math.round(this.speed * 100) / 100}
                <span id="speed" class="splitButton">
                  <span class="buttonLeft">${(this.upgrades.speed == 2) ? "Max" : "→&nbsp;" + Math.round(this.speed * 1.5 * 100) / 100}</span><span class="buttonRight">$${this.upgradePrice("speed")}</span>
                </span>
              </h2>

              <h2>
                Strength: ${Math.round(this.strength * 100) / 100}
                <span id="strength" class="splitButton">
                  <span class="buttonLeft">${(this.upgrades.strength == 2) ? "Max" : "→&nbsp;" + Math.round(this.strength * 2 * 100) / 100}</span><span class="buttonRight">$${this.upgradePrice("strength")}</span>
                </span>
              </h2>

              <h2>
                Extra ${this.extra1.bought ? "2" : "1"}
                <span id="extra" class="splitButton">
                  <span class="buttonLeft">${this.extra2.bought ? "Bought" : "Add"}</span><span class="buttonRight">$${this.nextExtra.price}</span>
                </span>
              </h2>
              ${this.nextExtra.description ?? this.extra2.description}

              <h2>
                Special power
                <span id="power" class="splitButton">
                  <span class="buttonLeft">${difficulty == "hard" ? "Locked" : (this.power.bought ? "Bought" : "Unlock")}</span><span class="buttonRight">$${this.power.price}</span>
                </span>
              </h2>
              ${type.power.description}
            `;
          document.getElementById("container").append(menu);

          let sellButton = document.getElementById("sell");
          let rangeButton = document.getElementById("range");
          let speedButton = document.getElementById("speed");
          let strengthButton = document.getElementById("strength");
          let extraButton = document.getElementById("extra");
          let powerButton = document.getElementById("power");

          //Gray out upgrades that can't be bought
          if (player.money < this.upgradePrice("range") || this.range == Infinity) rangeButton.classList.add("unselectable");
          if (player.money < this.upgradePrice("speed")) speedButton.classList.add("unselectable");
          if (player.money < this.upgradePrice("strength")) strengthButton.classList.add("unselectable");
          if (player.money < this.nextExtra.price) extraButton.classList.add("unselectable");
          if (player.money < this.power.price || this.power.bought || difficulty == "hard") powerButton.classList.add("unselectable");

          if (this.upgrades.range == 2 || this.range == Infinity) rangeButton.classList.add("bought");
          if (this.upgrades.speed == 2) speedButton.classList.add("bought");
          if (this.upgrades.strength == 2) strengthButton.classList.add("bought");
          if (this.extra2.bought) extraButton.classList.add("bought");
          if (this.power.bought || difficulty == "hard") powerButton.classList.add("bought");

          //Center the menu horizontally
          menu.style.left = this.x / 1920 * 100 + "%";
          menu.style.transform = "translateX(-50%)";
          let menuRect = menu.getBoundingClientRect();
          let gameRect = document.getElementById("game").getBoundingClientRect();
          //If the menu is too far to the left or right, put it on the edge
          if (menuRect.x < gameRect.x) {
            menu.style.left = "0";
            menu.style.transform = "";
          } else if (menuRect.x + menuRect.width > gameRect.x + gameRect.width) {
            menu.style.left = "";
            menu.style.right = "0";
            menu.style.transform = "";
          }
          menu.style.bottom = 100 - (this.y / 1080 * 100) + 10 + "%";
          menuRect = menu.getBoundingClientRect(); //Get the menu position again
          //If the menu goes above the top of the game, put it below the tower
          if (menuRect.y < gameRect.y) {
            menu.style.bottom = "";
            menu.style.top = this.y / 1080 * 100 + 10 + "%";
          }

          //Remove the tower and give back 75% of all money spent on it
          sellButton.onclick = () => {
            towers[this.i] = null;
            player.money += this.sellValue;
            let row = Math.floor(this.y / 60);
            let col = Math.floor(this.x / 60);
            grid[row][col] = null; //Reset the grid square
            menu.remove();
            let squareEl = document.getElementById("r" + row + "c" + col);
            squareEl.classList.remove("tower");
            squareEl.onclick = null;
            this.menuOpen = false;
            //Remove bonuses
            if (this.name == "Money Tower") {
              if (this.extra1.bought) player.bonusMoney -= 0;
              if (this.extra2.bought) player.bonusLives -= 1;
            }
          };
          rangeButton.onclick = () => {
            if (this.upgrades.range < 2 && player.money >= this.upgradePrice("range") && this.range != Infinity) {
              player.money -= this.upgradePrice("range");
              this.value += this.upgradePrice("range");
              this.upgrades.range++;
              this.range *= 1.25;
              //Update the menu
              menu.remove();
              this.showMenu();
            }
          };
          speedButton.onclick = () => {
            if (this.upgrades.speed < 2 && player.money >= this.upgradePrice("speed")) {
              player.money -= this.upgradePrice("speed");
              this.value += this.upgradePrice("speed");
              this.upgrades.speed++;
              this.speed *= 1.5;
              //Update the menu
              menu.remove();
              this.showMenu();
            }
          };
          strengthButton.onclick = () => {
            if (this.upgrades.strength < 2 && player.money >= this.upgradePrice("strength")) {
              player.money -= this.upgradePrice("strength");
              this.value += this.upgradePrice("strength");
              this.upgrades.strength++;
              this.strength *= 2;
              //Update the menu
              menu.remove();
              this.showMenu();
            }
          };
          extraButton.onclick = () => {
            if (!this.extra2.bought && player.money >= this.nextExtra.price) {
              player.money -= this.nextExtra.price;
              this.value += this.nextExtra.price;
              this.nextExtra.add.bind(this)();
              this.nextExtra.bought = true;
              //Update the menu
              menu.remove();
              this.showMenu();
            }
          };
          powerButton.onclick = () => {
            if (!this.power.bought && player.money >= this.power.price && difficulty == "normal") {
              player.money -= this.power.price;
              this.value += this.power.price;
              this.power.bought = true;
              //Update the menu
              menu.remove();
              this.showMenu();
            }
          };

          this.closeMenu = () => {
            menu.remove();
            this.menuOpen = false;
          }
          document.getElementById("grid").onmousedown = this.closeMenu;
          document.addEventListener("keydown", e => {
            if (e.key == "Escape") this.closeMenu();
          });
        }
        this.upgradePrice = stat => {
          switch (this.upgrades[stat]) {
            case 2:
              return Infinity;
            case 1:
              return this.price * 3;
            default:
              return this.price;
          }
        }
      }

      get sellValue() {
        return Math.round(this.value * 0.75);
      }

      get nextExtra() {
        return this.extra2.bought ? { price: Infinity } : (this.extra1.bought ? this.extra2 : this.extra1);
      }
    }

    class Enemy {
      constructor(string) {
        //Set the enemy type based on the first letter
        switch (string[0]) {
          case "g":
            this.type = enemyTypes.green;
            break;
          case "y":
            this.type = enemyTypes.yellow;
            break;
          case "o":
            this.type = enemyTypes.orange;
            break;
          case "r":
            this.type = enemyTypes.red;
            break;
          case "p":
            this.type = enemyTypes.purple;
            break;
          case "b":
            this.type = enemyTypes.brown;
            break;
          case "x":
            this.type = enemyTypes.boss;
            break;
          case "z":
            this.type = enemyTypes.brownBoss;
            break;
          case "u":
            this.type = enemyTypes.purpleBoss;
        }
        this.speed = this.type.speed;
        this.health = this.type.health;
        //this.health = this.type.health * Math.ceil((currentWave + 1) / 10); //Increase enemies' HP every 10 rounds
        this.abilities = [];
        //Give the enemy an ability is there is a second character
        //Despite this.abilities being an array, an enemy can only have one ability in the current version of the game
        switch (string[1]) {
          case "h":
            this.abilities.push("healing");
            break;
          case "a":
            this.abilities.push("acceleration");
            break;
          case "s":
            this.abilities.push("split");
            break;
          case "k":
            this.abilities.push("blink");
            break;
          case "d":
            this.abilities.push("shield");
        }
        this.id = Math.random(); //Give the enemy a random ID so that no two enemy objects are identical
        this.distance = 0;
        if (this.abilities.includes("blink")) {
          this.visible = !!(blinkingCount % 2); //Every other blinking enemy will start off invisible
          if (Math.floor(frame / 100) % 2) this.visible = !this.visible; //Blinking enemies switch states every 100 frames
          blinkingCount++;
        } else {
          this.visible = true;
        }
        this.slowed = 0;
        this.poisoned = 0;
        this.hit = function (damage, tower, type) {
          if (this.stunned) damage *= 2;
          let shieldProtection = this.abilities.includes("shield") && !this.noAbilities && type != "explosion" && type != "poison" && tower?.name != "Long-Range Tower" //Only explosions, poison, and Long-Range Towers can damage shielded enemies
          if (!shieldProtection) this.health -= damage;

          if (this.health < 0.001) {
            let i = enemies.indexOf(this);
            player.money += (this.type.boss ? 10 : 1) * (tower?.extraMoney ? 3 : 1);
            if (this.abilities.includes("split")) {
              let type;
              if (this.type == enemyTypes.boss) {
                let new1 = new Enemy("p");
                let new2 = new Enemy("p");
                let new3 = new Enemy("b");
                let new4 = new Enemy("b");
                new1.distance = this.distance;
                new2.distance = this.distance - 20;
                new3.distance = this.distance - 40;
                new4.distance = this.distance - 60;
                enemies.splice(i, 1, new1, new2, new3, new4);
              } else {
                switch (this.type) {
                  case enemyTypes.yellow:
                    type = "g";
                    break;
                  case enemyTypes.orange:
                    type = "y";
                    break;
                  case enemyTypes.red:
                    type = "o";
                    break;
                  case enemyTypes.purple:
                  case enemyTypes.brown:
                    type = "r";
                }
                let new1 = new Enemy(type);
                let new2 = new Enemy(type);
                new1.distance = this.distance;
                new2.distance = this.distance - 20;
                enemies.splice(i, 1, new1, new2);
              }
            } else {
              enemies.splice(i, 1); //Remove the enemy
            }
          } else {
            if (this.abilities.includes("acceleration") && !this.noAbilities) this.speed = this.type.speed + this.type.speed * (1 - (this.health / this.type.health)) * 3; //Normal speed + (normal speed * portion of health lost * 3)
            if (tower?.removeAbilities) this.abilities = [];
          }
        }
      }
    }

    let grid = Array(15).fill().map(() => Array(32).fill(null)); //Array containing 15 arrays (rows), each containing 32 items (columns). Makes a deep copy of each array.

    //All images used in the game except towers & enemies
    let images = {
      buttons: {
        fullscreen: new Image(),
        exitFullscreen: new Image(),
        sound: new Image(),
        noSound: new Image(),
        showAlerts: new Image(),
        noAlerts: new Image(),
        pause: new Image(),
        play: new Image(),
        fastForward: new Image()
      },
      abilitySymbols: {
        healing: new Image(),
        shield: new Image(),
        acceleration: new Image()
      },
      planes: {
        left: new Image(),
        right: new Image(),
        up: new Image(),
        down: new Image(),
      },
      superPlanes: {
        left: new Image(),
        right: new Image(),
        up: new Image(),
        down: new Image(),
      }
    };
    for (let button in images.buttons) images.buttons[button].src = `../../static/img/towerdefense/${button}.png`;
    for (let symbol in images.abilitySymbols) images.abilitySymbols[symbol].src = `../../static/img/towerdefense/${symbol}.png`;
    for (let plane in images.planes) images.planes[plane].src = `../../static/img/towerdefense/air-${plane}.png`;
    for (let plane in images.superPlanes) images.superPlanes[plane].src = `../../static/img/towerdefense/superPlane-${plane}.png`;

    //Sound settings and list of sound effects
    let sound = {
      enabled: true,
      delay: 0.05, //How long each sound effect must play before it can start over
      sfx: {
        powerReady: new Audio("../../static/sound/td/td_power_ready.wav"),
        blip: new Audio("../../static/sound/td/td_blip01.wav"),
        coin1: new Audio("../../static/sound/td/td_coin01.wav"),
        coin2: new Audio("../../static/sound/td/td_coin02.wav"),
        explode1: new Audio("../../static/sound/td/td_explode01.wav"),
        explode2: new Audio("../../static/sound/td/td_explode02.wav"),
        explode3: new Audio("../../static/sound/td/td_explode03.wav"),
        laser: new Audio("../../static/sound/td/td_laser01.wav"),
        powerUp1: new Audio("../../static/sound/td/td_powerup01.wav"),
        powerUp2: new Audio("../../static/sound/td/td_powerup02.wav"),
        shoot: new Audio("../../static/sound/td/td_shoot02.wav"),
        success: new Audio("../../static/sound/td/td_success01.wav"),
        basicHit: new Audio("../../static/sound/td/td_hit01.wav"),
        slowingHit: new Audio("../../static/sound/td/td_slow_hit.wav"),
        poisonHit: new Audio("../../static/sound/td/td_poison_hit.wav"),
        moneyHit: new Audio("../../static/sound/td/td_money_hit.wav"),
        planeHit: new Audio("../../static/sound/td/td_plane_hit.wav"),
        ultimateHit: new Audio("../../static/sound/td/td_ultimate_hit.wav"),
        longRangeHit: new Audio("../../static/sound/td/td_longrange_hit.wav")
      },
      playSFX: function (name) {
        if (this.enabled) {
          let delay = this.sfx[name].delay || this.delay;
          if (this.sfx[name].currentTime >= delay) this.sfx[name].currentTime = 0;
          this.sfx[name].play();
        }
      }
    };
    //Turn down the volume of each of the sound effects
    for (const effect in sound.sfx) {
      sound.sfx[effect].volume = 0.2;
    }
    //Manually adjust some sound effects
    sound.sfx.ultimateHit.delay = sound.delay / 2;
    sound.sfx.blip.volume = 0.5;
    sound.sfx.slowingHit.volume = 0.1;
    sound.sfx.longRangeHit.volume = 0.15;
    sound.sfx.planeHit.volume = 0.15;
    sound.sfx.ultimateHit.volume = 0.4;
    sound.sfx.shoot.volume = 0.6;
    for (let type in towerTypes) towerTypes[type].hitSound = type + "Hit"; //Give all towers except for Cannon Towers different hit sounds
    towerTypes.air.hitSound = "planeHit";

    let canvas = document.getElementById("game");
    let ctx = canvas.getContext("2d");

    ctx.drawCircle = function (x, y, r) {
      this.beginPath();
      this.arc(x, y, r, 0, 2 * Math.PI);
      this.stroke();
      this.fill();
    }

    ctx.drawPath = function (instructions) {
      this.lineWidth = 1.5;
      this.strokeStyle = "#80ffff";
      this.beginPath();
      let xPos = instructions.start[0] * 60;
      let yPos = instructions.start[1] * 60;
      let col = instructions.start[0] - 0.5;
      let row = instructions.start[1] - 0.5;
      instructions.lines.forEach(line => {
        this.moveTo(xPos, yPos);
        for (let i = 0; i < line[1]; i++) {
          switch (line[0]) {
            case "right":
              xPos += 60;
              col++;
              break;
            case "left":
              xPos -= 60;
              col--;
              break;
            case "down":
              yPos += 60;
              row++;
              break;
            case "up":
              yPos -= 60;
              row--;
          }
          this.lineTo(xPos, yPos);
          if (grid[row] && grid[row][col] === null) grid[row][col] = "track"; //Change the value of every square the path goes through
        }
      });
      this.stroke();
    }

    ctx.drawPreview = function (instructions) {
      this.lineWidth = 1.5;
      this.strokeStyle = "#80ffff";
      this.beginPath();
      let xPos = instructions.start[0] * 30 + 480;
      let yPos = instructions.start[1] * 30 + 120;
      instructions.lines.forEach(line => {
        let startX = xPos;
        let startY = yPos;
        if (startX < 480) startX = 480;
        if (startX > 1440) startX = 1440;
        if (startY < 120) startY = 120;
        if (startY > 570) startY = 570;
        this.moveTo(startX, startY);
        for (let i = 0; i < line[1]; i++) {
          switch (line[0]) {
            case "right":
              xPos += 30;
              break;
            case "left":
              xPos -= 30;
              break;
            case "down":
              yPos += 30;
              break;
            case "up":
              yPos -= 30;
          }
          let endX = xPos;
          let endY = yPos;
          if (endX < 480) endX = 480;
          if (endX > 1440) endX = 1440;
          if (endY < 120) endY = 120;
          if (endY > 570) endY = 570;
          this.lineTo(endX, endY);
        }
      });
      this.stroke();
    }

    function update() {
      ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas
      ctx.drawPath(map);

      //Buttons in the top-left corner

      //Fullscreen button
      ctx.drawImage(document.fullscreenElement ? images.buttons.exitFullscreen : images.buttons.fullscreen, 15, 15, 30, 30);
      document.getElementById("r0c0").classList.add("gameButton");
      document.getElementById("r0c0").onclick = () => {
        if (!paused) {
          if (document.fullscreenElement) document.exitFullscreen();
          else document.documentElement.requestFullscreen();
        } else {
          //Resume button
          paused = false;
          animate = setInterval(update, fastForward ? 10 : 40);
          document.getElementById("towers").classList.remove("hidden");
          if (document.getElementById("alert")) hideAlert(); //If there is an alert, hide it
        }
      };
      //Sound button
      ctx.drawImage(sound.enabled ? images.buttons.sound : images.buttons.noSound, 75, 15, 30, 30);
      document.getElementById("r0c1").classList.add("gameButton");
      document.getElementById("r0c1").onclick = () => {
        if (!paused) sound.enabled = !sound.enabled
      };
      //Alerts button
      ctx.drawImage(noAlerts ? images.buttons.noAlerts : images.buttons.showAlerts, 135, 15, 30, 30);
      document.getElementById("r0c2").classList.add("gameButton");
      document.getElementById("r0c2").onclick = () => {
        if (!paused) {
          if (noAlerts === undefined) gameAlert("No more alerts will be shown.");
          noAlerts = !noAlerts;
        }
      };
      //Pause button
      ctx.drawImage(images.buttons.pause, 195, 15, 30, 30);
      document.getElementById("r0c3").classList.add("gameButton");
      document.getElementById("r0c3").onclick = () => {
        if (!paused) {
          paused = true;
          clearInterval(animate);
          document.getElementById("towers").classList.add("hidden");
          for (let i = 1; i < 5; i++) document.getElementById("r0c" + i).classList.remove("gameButton");
          //Prevent placing towers while paused
          grid.forEach((row, i) => row.forEach((square, j) => {
            let squareEl = document.getElementById("r" + i + "c" + j);
            if (squareEl.ondragleave) squareEl.ondragleave();
          }));
          for (let tower in towerTypes) if (towerTypes[tower].dragging) document.getElementById(tower).ondragend();
          //If a tower's menu is open, close it
          let menuTower = towers.find(tower => tower?.menuOpen);
          menuTower?.closeMenu();
          ctx.clearRect(0, 0, 300, 60);
          ctx.drawImage(fastForward ? images.buttons.fastForward : images.buttons.play, 15, 15, 30, 30);
        }
      };
      //Fast forward button (normal mode only)
      if (difficulty == "normal") {
        ctx.drawImage(fastForward ? images.buttons.play : images.buttons.fastForward, 255, 15, 30, 30);
        document.getElementById("r0c4").classList.add("gameButton");
        document.getElementById("r0c4").onclick = () => {
          if (!paused) {
            fastForward = !fastForward;
            clearInterval(animate);
            animate = setInterval(update, fastForward ? 10 : 40); //If fast forward is turned on, play at 4x the normal speed
          }
        };
      }

      if (dragOver && dragOver[0].name != "Air Tower") {
        ctx.lineWidth = 1;
        ctx.strokeStyle = "white";
        ctx.fillStyle = "#aaa5";
        ctx.drawCircle(dragOver[1] * 60 + 30, dragOver[2] * 60 + 30, dragOver[0].range * 60);
      }

      //Spawn enemies
      if (!(frame % 4)) { //Do this every 4 frames
        let next = map.waves[currentWave][currentEnemy];
        while (Array.isArray(next)) {
          if (next[0] == "alert") {
            if (!noAlerts) gameAlert(next[1]);
            map.waves[currentWave].splice(currentEnemy, 1); //Remove the array
          } else {
            let repeat = next[0]; //The array's first item is the number of times to repeat
            let items = next.slice(1); //Everything that follows is repeated
            let repeated = Array(repeat).fill(items).flat(); //Make an array containing the items array repeated, then flatten it
            map.waves[currentWave].splice(currentEnemy, 1, ...repeated); //Add each item in repeated to the wave and remove the array
          }
          next = map.waves[currentWave][currentEnemy];
        }
        //Add next enemy
        if (next) {
          let newEnemy = new Enemy(next);
          enemies.push(newEnemy);
        }

        if (map.waves[currentWave][currentEnemy + 1] !== undefined) { //If there are enemies left in the wave
          currentEnemy++;
        } else {
          if (!map.waves[currentWave + 1]) { //If there are no waves left
            //Once all enemies are defeated, end the game
            if (enemies.length) {
              map.waves[currentWave].push(null);
            } else {
              endGame(true);
              return;
            }
          } else {
            currentWave++;
            currentEnemy = 0;
          }
          //if (currentWave == 50) for (let type in enemyTypes) enemyTypes[type].health *= 2; //All enemy types get double health for the last 25 rounds of hard mode
        }
      }

      enemies.forEach((enemy, i) => {
        //If the enemy is at the end of the track, subtract a life and remove it from the array
        //Otherwise, draw it in its new position
        if (enemy.distance >= mapArr.length) {
          player.lives -= enemy.type.health;
          if (player.lives) sound.playSFX("blip");
          gameAchievements[0] = 0;
          enemies.splice(i, 1);
        } else {
          if (enemy.reverse) {
            enemy.distance -= enemy.speed * (enemy.slowed ? 2 : 4);
            enemy.reverse--;
          } else if (enemy.stunned) {
            enemy.stunned--;
          } else {
            enemy.distance += enemy.speed * (enemy.slowed ? 2 : 4);
          }
          if (enemy.slowed) enemy.slowed--;
          if (enemy.poisoned && --enemy.poisoned % (enemy.doublePoisoned ? 12.5 : 25) < 1) enemy.hit(0.6, null, "poison");
          if (!enemy.poisoned) delete enemy.doublePoisoned;

          enemy.x = map.start[0] * 60;
          enemy.y = map.start[1] * 60;
          let img = enemy.type.img;
          for (let j = 0; j < Math.round(enemy.distance); j++) {
            //Move the enemy forward
            switch (mapArr[j]) {
              case "right":
                enemy.x++;
                break;
              case "left":
                enemy.x--;
                break;
              case "down":
                enemy.y++;
                break;
              case "up":
                enemy.y--;
            }
            if (enemy.abilities.includes("split")) {
              img = (enemy.type.boss && (mapArr[j] == "right" || mapArr[j] == "left")) ? enemy.type.imgSplitRotated : enemy.type.imgSplit; //If the enemy is a boss and moving horizontally, rotate it
            } else if (enemy.type.boss && (mapArr[j] == "right" || mapArr[j] == "left")) {
              img = enemy.type.imgRotated;
            } else {
              img = enemy.type.img;
            }
          }
          if (!enemy.visible) ctx.globalAlpha = 0.25; //If the enemy is hidden, make it semitransparent
          ctx.drawImage(img, enemy.x - 40, enemy.y - 40);
          ctx.globalAlpha = 1;
          //Draw ability symbols inside the enemy
          if (enemy.abilities.includes("healing") && !enemy.noAbilities) ctx.drawImage(images.abilitySymbols.healing, enemy.x - 40, enemy.y - 40);
          if (enemy.abilities.includes("shield") && !enemy.noAbilities) ctx.drawImage(images.abilitySymbols.shield, enemy.x - 40, enemy.y - 40);
          if (enemy.abilities.includes("acceleration") && !enemy.noAbilities) ctx.drawImage(images.abilitySymbols.acceleration, enemy.x - 40, enemy.y - 40);
        }

        if (enemy.abilities.includes("healing") && enemy.health < enemy.type.health && !enemy.noAbilities) {
          enemy.health += 1 / 75;
          if (enemy.health > enemy.type.health) enemy.health = enemy.type.health; //Don't let the enemy's health go above the initial value
        }
        if (enemy.abilities.includes("blink")) {
          if (!(frame % 100)) enemy.visible = !enemy.visible;
        } else {
          enemy.visible = true;
        }
        if (enemy.noAbilities) enemy.visible = true;

        if (enemy.noAbilities) enemy.noAbilities--;
      });

      towers.forEach(tower => {
        if (!tower) return; //If the tower has been sold, skip this
        ctx.drawImage(tower.img, tower.x - 30, tower.y - 30);

        if (tower.name == "Air Tower") {
          tower.planeDistance += 8;
          tower.planeX = tower.planeStartX;
          tower.planeY = tower.planeStartY;
          let img;
          for (let i = 0; i < Math.round(tower.planeDistance); i++) {
            let j = i;
            while (j >= planePathArr.length) j -= planePathArr.length;
            switch (planePathArr[j]) {
              case "right":
                tower.planeX++;
                break;
              case "left":
                tower.planeX--;
                break;
              case "down":
                tower.planeY++;
                break;
              case "up":
                tower.planeY--;
            }
            img = images.planes[planePathArr[j]];
          }
          ctx.drawImage(img, tower.planeX - 30, tower.planeY - 30);
        }

        if (tower.menuOpen) {
          //Show the tower's range
          ctx.lineWidth = 1;
          ctx.strokeStyle = "white";
          ctx.fillStyle = "#aaa5";
          let x = (tower.name == "Air Tower") ? tower.planeX : tower.x;
          let y = (tower.name == "Air Tower") ? tower.planeY : tower.y;
          let range = tower.range;
          if (towers.find(owned => owned?.rangeBoosted == tower)) range *= 1.25;
          if (tower.ultimateBoost) range *= 2;
          ctx.drawCircle(x, y, range * 60);
        }

        if (tower.rangeBoosting) {
          let otherTowers = towers.filter(owned => owned && owned != tower && owned.range != Infinity); //Remove this tower, sold towers, and Long-Range Towers
          let closest = otherTowers.sort((a, b) => ((tower.planeX - a.x) ** 2 + (tower.planeY - a.y) ** 2) - ((tower.planeX - b.x) ** 2 + (tower.planeY - b.y) ** 2))[0];
          tower.rangeBoosted = closest;
        }

        if (tower.cooldown > 1) {
          let reduceCooldown = 1;
          if (tower.speedBoost) reduceCooldown *= 5;
          if (tower.ultimateBoost) reduceCooldown *= 2;
          tower.cooldown -= reduceCooldown;
        } else {
          let x = (tower.name == "Air Tower") ? tower.planeX : tower.x;
          let y = (tower.name == "Air Tower") ? tower.planeY : tower.y;
          let range = tower.range;
          if (towers.find(owned => owned?.rangeBoosted == tower)) range *= 1.25; //Range boost from Air Tower
          if (tower.ultimateBoost) range *= 2;
          let inRange = enemies.filter(enemy => Math.sqrt((x - enemy.x) ** 2 + (y - enemy.y) ** 2) < range * 60); //Use the Pythagorean Theorem to determine if each enemy is inside the tower's range
          if (!tower.seeInvisible) inRange = inRange.filter(enemy => enemy.visible);
          if (inRange.length) {
            let furthest = inRange.sort((a, b) => b.distance - a.distance)[0]; //Sort inRange from highest to lowest distance and get the first item
            let strong = inRange.sort((a, b) => b.health - a.health); //Sort inRange from highest to lowest health
            let strongest = strong.find(enemy => enemy.abilities.includes("shield")) || strong[0]; //Target shielded enemies
            let target = (tower.name == "Long-Range Tower") ? strongest : furthest;
            let damage = tower.strength;
            if (tower.crowdBonus) damage *= 1 + enemies.length / 100; //Increase the damage by 1% for each enemy onscreen
            console.log(target)
            if (tower.bossBonus && target.type.boss) damage *= 2.5;
            if (tower.ultimateBoost) damage *= 2;
            target.hit(damage, tower);

            if (sound.sfx[tower.hitSound]) sound.playSFX(tower.hitSound, tower.name); //Play hit sound

            if (tower.slowing && !target.abilities.includes("acceleration")) target.slowed = tower.permSlow ? Infinity : 250;
            if (tower.abilityBlocking && !target.abilities.includes("acceleration")) target.noAbilities = tower.permSlow ? Infinity : 250;
            if (tower.poison && !target.abilities.includes("healing")) {
              target.poisoned = 125; //Poison the target for 125 frames
              if (tower.doublePoison) target.doublePoisoned = true;
            }
            if (tower.bounce) {
              let bouncePath = [target]; //Make an array of all enemies hit so they aren't bounced to again
              let close = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < 100 && !bouncePath.includes(enemy) && enemy.visible);
              let bouncesLeft = tower.bounce;
              while (close.length && bouncesLeft) { //While the projectile can still bounce and there are enemies to bounce to
                let closest = close.sort((a, b) => ((target.x - a.x) ** 2 + (target.y - a.y) ** 2) - ((target.x - b.x) ** 2 + (target.y - b.y) ** 2))[0];
                let distance = Math.sqrt((target.x - closest.x) ** 2 + (target.y - closest.y) ** 2);
                let oldTarget = target;
                target = closest;

                ctx.lineWidth = 4;
                ctx.strokeStyle = tower.color;
                ctx.beginPath();
                ctx.moveTo(oldTarget.x, oldTarget.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();

                damage = tower.strength;
                if (tower.ultimateBoost) damage *= 2;
                target.hit(damage, tower);
                bouncePath.push(target);
                close = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < 100 && !bouncePath.includes(enemy) && enemy.visible);
                bouncesLeft--;
              }
            }
            if (tower.poisonSplash) {
              let close = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < 100 && enemy != target && enemy.visible);
              if (close.length) {
                let closest = close.sort((a, b) => ((target.x - a.x) ** 2 + (target.y - a.y) ** 2) - ((target.x - b.x) ** 2 + (target.y - b.y) ** 2))[0];
                let distance = Math.sqrt((target.x - closest.x) ** 2 + (target.y - closest.y) ** 2);
                target = closest;
                target.poisoned = 125;
                if (tower.doublePoison) target.doublePoisoned = true;
              }
            }
            if (tower.nextExplosion === 0) tower.explosionSize = 75;
            if (tower.explosionSize) { //If the hit causes an explosion
              //Create an explosion centered around the target enemy
              let inExplosion = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < tower.explosionSize);
              let explosionDamage = tower.powerfulExplosions ? tower.strength : 1;
              inExplosion.forEach(enemy => enemy.hit(explosionDamage, tower, "explosion")); //Do damage to every enemy inside the explosion
              //Draw the explosion as an orange circle
              ctx.strokeStyle = "transparent";
              ctx.fillStyle = "#ff8f4055";
              ctx.drawCircle(target.x, target.y, tower.explosionSize);
              sound.playSFX("explode1");
            }
            if (tower.nextExplosion) {
              tower.nextExplosion--;
            } else if (tower.nextExplosion === 0) {
              delete tower.explosionSize;
              tower.nextExplosion = 5;
            }

            ctx.drawImage(tower.activeImg, tower.x - 30, tower.y - 30); //Light up the firing tower for 1 frame

            //Draw line of fire
            ctx.lineWidth = 4;
            ctx.strokeStyle = tower.color;
            ctx.beginPath(); //Start a new path
            if (tower.name == "Air Tower") ctx.moveTo(tower.planeX, tower.planeY);
            else ctx.moveTo(tower.x, tower.y);
            ctx.lineTo(target.x, target.y);
            ctx.stroke(); //Render the path

            tower.cooldown += 25 / tower.speed;
          }
        }

        if (tower.speedBoost) tower.speedBoost--;
        if (tower.ultimateBoost) tower.ultimateBoost--;

        if (tower.upgrades.range == 2 && tower.upgrades.speed == 2 && tower.upgrades.strength == 2 && tower.extra2.bought) gameAchievements[2] = 1;
      });

      if (superPlane) {
        superPlane.distance += 12;
        if (superPlane.distance > superPlanePathArr.length) {
          superPlane = null;
        } else {
          superPlane.x = superPlane.initialX;
          superPlane.y = superPlane.initialY;
          let img;
          for (let i = 0; i < Math.round(superPlane.distance); i++) {
            switch (superPlanePathArr[i]) {
              case "right":
                superPlane.x++;
                break;
              case "left":
                superPlane.x--;
                break;
              case "down":
                superPlane.y++;
                break;
              case "up":
                superPlane.y--;
            }
            img = images.superPlanes[superPlanePathArr[i]];
          }
          ctx.drawImage(img, superPlane.x - 45, superPlane.y - 45);

          if (superPlane.cooldown > 1) {
            superPlane.cooldown--;
          } else {
            let inRange = enemies.filter(enemy => Math.sqrt((superPlane.x - enemy.x) ** 2 + (superPlane.y - enemy.y) ** 2) < superPlane.range * 60 && enemy.visible);
            if (inRange.length) {
              let target = inRange.sort((a, b) => b.distance - a.distance)[0];
              target.hit(superPlane.strength);
              sound.playSFX("planeHit");
              ctx.lineWidth = 4;
              ctx.strokeStyle = "#ff6860";
              ctx.beginPath();
              ctx.moveTo(superPlane.x, superPlane.y);
              ctx.lineTo(target.x, target.y);
              ctx.stroke();

              superPlane.cooldown += 25 / superPlane.speed;
            }
          }
        }
      }

      for (let tower in towerTypes) {
        let towerEl = document.getElementById(tower);

        if (towerTypes[tower].power.cooldown) {
          towerTypes[tower].power.cooldown--;
          if (!towerTypes[tower].power.cooldown) {
            let powerEl = document.getElementById(tower + "Power");
            powerEl.classList.add("powerReady");
            setTimeout(() => powerEl.classList.remove("powerReady"), 1000);
            sound.playSFX("powerReady");
          }
        }

        if (player.money >= towerTypes[tower].price) {
          towerEl.classList.remove("unselectable");
          towerEl.draggable = true;
          //Do this when the tower is picked up
          towerEl.ondragstart = () => {
            towerTypes[tower].dragging = true;
            document.getElementById("grid").classList.add("visibleLines"); //Show the grid's lines
            grid.forEach((row, i) => row.forEach((square, j) => {
              let squareEl = document.getElementById("r" + i + "c" + j);
              if (square) { //If the square is not null
                squareEl.ondragover = () => squareEl.classList.add("undroppable");
                squareEl.ondragleave = () => squareEl.classList.remove("undroppable");
                squareEl.ondrop = () => squareEl.classList.remove("undroppable");
              } else {
                squareEl.ondragover = () => {
                  event.preventDefault();
                  squareEl.classList.add("droppable");
                  dragOver = [towerTypes[tower], j, i]; //Save the tower being sragges, the column, and the row
                };
                squareEl.ondragleave = () => {
                  squareEl.classList.remove("droppable");
                  dragOver = null;
                };
                squareEl.ondrop = () => {
                  squareEl.classList.remove("droppable");
                  dragOver = null;
                  document.getElementById("grid").classList.remove("visibleLines");
                  if (player.money >= towerTypes[tower].price) { //Check that the player can afford the tower again to prevent cheating
                    //Place the tower
                    player.money -= towerTypes[tower].price;
                    let newTower = new Tower(towerTypes[tower], i, j);
                    towers.push(newTower);
                    grid[i][j] = newTower;
                    let squareEl = document.getElementById("r" + i + "c" + j);
                    squareEl.classList.add("tower");
                    squareEl.onclick = () => newTower.showMenu();
                    towerTypes[tower].placed = true;
                    if (Object.values(towerTypes).every(tower => tower.placed)) gameAchievements[1] = 1;
                    if (newTower.name == "Ultimate Tower") gameAchievements[4] = 0;
                    if (newTower.name == "Basic Tower") gameAchievements[5] = 0;
                    if (towers.length == 4) gameAchievements[6] = 0;
                  }
                };
              }
            }));
          };
          towerEl.ondragend = () => {
            delete towerTypes[tower].dragging;
            dragOver = null;
            document.getElementById("grid").classList.remove("visibleLines");
            grid.forEach((row, i) => row.forEach((square, j) => {
              let squareEl = document.getElementById("r" + i + "c" + j);
              squareEl.ondragover = null;
              squareEl.ondragleave = null;
              squareEl.ondrop = null;
            }));
          };
        } else {
          towerEl.classList.add("unselectable");
          towerEl.draggable = false;
        }

        let power = towerTypes[tower].power;
        let powerButton = document.getElementById(tower + "Power");
        if (power.bought && towers.find(owned => owned?.name == towerTypes[tower].name)) {
          powerButton.classList.remove("invisible");
          if (power.cooldown) {
            powerButton.classList.add("unselectable");
            let percent = power.cooldown / 3000 * 100;
            powerButton.style.background = `linear-gradient(to left, var(--emphasis-color), var(--emphasis-color) ${percent}%, gray ${percent}%)`; //Show how long until the power can be used again
          } else {
            powerButton.style.background = null; //Reset the background
            powerButton.classList.remove("unselectable");
          }
        } else {
          powerButton.classList.add("invisible");
        }
      }

      if (!(frame % 250)) player.money += player.bonusMoney;
      if (!(frame % 375)) player.lives += player.bonusLives;

      let menuTower = towers.find(tower => tower?.menuOpen);
      if (menuTower) {
        if (player.money >= menuTower.upgradePrice("range") && menuTower.range !== Infinity) document.getElementById("range").classList.remove("unselectable");
        if (player.money >= menuTower.upgradePrice("speed")) document.getElementById("speed").classList.remove("unselectable");
        if (player.money >= menuTower.upgradePrice("strength")) document.getElementById("strength").classList.remove("unselectable");
        if (player.money >= menuTower.nextExtra.price) document.getElementById("extra").classList.remove("unselectable");
        if (player.money >= menuTower.power.price && !menuTower.power.bought && difficulty == "normal") document.getElementById("power").classList.remove("unselectable");
      }

      //Update text in top-right
      ctx.font = "30px monospace";
      ctx.textAlign = "left";
      if (player.lives > 0) {
        //Display time, money, and lives in the top-right corner
        ctx.fillStyle = "#ddd";
        ctx.fillText(`${(currentWave + 1).toString().padStart(2, "0")}/${map.waves.length}`, 1564, 40); //Show current and total waves
        ctx.fillStyle = "#80ff80";
        ctx.fillText("$" + player.money.toString().padStart(5, "0"), 1684, 40);
        ctx.fillStyle = "#ff6860";
        ctx.fillText("❤︎" + player.lives.toString().padStart(3, "0"), 1820, 40);
      } else {
        endGame();
      }

      frame++;
    }

    let progress = "{{ progress }}"; //2 means map completed on hard, 1 means map completed on normal, 0 means map not completed
    let achievements = "{{ achievements }}" || "0000000"; //1 means earned, 0 means not earned
    achievements = achievements.split("");
    let player = {
      money: 75,
      lives: 100,
      bonusMoney: 0,
      bonusLives: 0
    };
    let mapIndex = 0;
    let map;
    let mapArr;
    let planePathArr;
    let superPlanePathArr;
    let difficulty = "normal";
    let gameAchievements = [1, 0, 0, 0, 1, 1, 1];
    let enemies = [];
    let blinkingCount = 0; //Keep track of blinking enemies to alternate between visible and invisible
    let towers = [];
    let frame = 0;
    let currentWave = 0;
    let currentEnemy = 0;
    let superPlane;
    let noAlerts;
    let paused;
    let fastForward;
    let dragOver;
    let animate;

    progress = progress.padEnd(maps.length, "0"); //Add zeroes to the end when maps are added
    if (progress.length > maps.length) progress = progress.slice(0, maps.length - progress.length); //Remove numbers from the end if maps are deleted
    request.open("POST", "/updateuser?field=tdProgress&value=" + progress);
    request.send();
    progress = progress.split(""); //Turn the string into an array

    let achievementList = [
      "Complete a game without losing any lives",
      "Purchase every tower type in one game",
      "Fully upgrade a tower",
      "Use every special power in one game",
      "Win a game without any Ultimate Towers",
      "Win a game without any Basic Towers",
      "Win a game without placing more than three towers"
    ];

    //Create the title
    ctx.drawPreview({
      start: [1, 3],
      lines: [
        ["right", 1],
        ["up", 1],
        ["down", 1],
        ["right", 1],
        ["left", 1],
        ["down", 3],
        ["right", 2],
        ["up", 2],
        ["right", 2],
        ["down", 2],
        ["left", 2],
        ["up", 2],
        ["right", 3],
        ["down", 2],
        ["right", 1],
        ["up", 1],
        ["down", 1],
        ["right", 1],
        ["up", 2],
        ["right", 1],
        ["down", 1],
        ["right", 1],
        ["up", 1],
        ["left", 1],
        ["down", 2],
        ["right", 2],
        ["up", 2],
        ["right", 1],
        ["down", 1],
      ]
    });
    ctx.drawPreview({
      start: [17, 2],
      lines: [
        ["down", 4],
        ["left", 2],
        ["up", 2],
        ["right", 3],
        ["down", 1],
        ["right", 1],
        ["up", 1],
        ["left", 1],
        ["down", 2],
        ["right", 2],
        ["up", 4],
        ["right", 1],
        ["down", 1],
        ["up", 1],
        ["left", 1],
        ["down", 2],
        ["right", 2],
        ["down", 1],
        ["right", 1],
        ["up", 1],
        ["left", 1],
        ["down", 2],
        ["right", 2],
        ["up", 2],
        ["right", 2],
        ["down", 2],
        ["right", 2],
        ["up", 1],
        ["left", 1],
        ["up", 1],
        ["right", 2],
        ["down", 1],
        ["right", 1],
        ["up", 1],
        ["left", 1],
        ["down", 2],
        ["right", 2]
      ]
    });
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.font = "48px Segoe UI";
    ctx.fillText("Click to continue", 960, 600);
    ctx.font = "32px Segoe UI";
    ctx.fillText("Created by Oley Birkeland", 960, 1000);
    let completeMaps = progress.reduce((a, b) => +a + +b); //Convert every character to a number and add
    let totalMaps = progress.length * 2;
    let completeAchv = achievements.reduce((a, b) => +a + +b);
    let totalAchv = achievementList.length;
    let progressEl = document.getElementById("progress");
    if (completeMaps == totalMaps && completeAchv == totalAchv) progressEl.classList.add("complete");
    let progressText = document.createElement("span");
    progressText.id = "progressText";
    progressText.innerText = `${completeMaps}/${totalMaps} complete`;
    progressEl.append(progressText);
    let achvText = document.createElement("div");
    achvText.id = "achievements";
    achvText.innerHTML = `<span>${completeAchv}/${totalAchv} achievements</span>`;
    let achvButton = document.createElement("button");
    achvButton.id = "achvButton";;
    achvButton.innerText = "Open list";
    achvButton.onclick = () => {
      let listText = "<ul>";
      achievementList.forEach((achievement, i) => {
        let earned = +achievements[i];
        let tag = earned ? "s" : "b";
        listText += `<li class=${earned ? "earned" : ""}><${tag}>${achievement}</${tag}></li>`;
      });
      listText += "</ul>";
      gameAlert(listText, true);
    }
    achvText.append(achvButton);
    progressEl.append(achvText);

    function showMaps() {
      document.getElementById("progress").classList.add("hidden");
      if (document.getElementById("alert")) hideAlert();
      ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas

      let container = document.getElementById("container");

      let back = document.createElement("div");
      back.id = "back";
      back.innerText = "🡄";
      back.onclick = () => window.location.reload();
      container.append(back);

      let left = document.createElement("div");
      let right = document.createElement("div");
      left.id = "prevMap";
      right.id = "nextMap";
      left.innerText = "◀";
      right.innerText = "▶";
      left.onclick = () => {
        (mapIndex == 0) ? mapIndex = maps.length - 1 : mapIndex--;
        switchMap();
      }
      right.onclick = () => {
        (mapIndex == maps.length - 1) ? mapIndex = 0 : mapIndex++;
        switchMap();
      }
      container.append(left);
      container.append(right);

      let difficultyButtons = document.createElement("div");
      difficultyButtons.id = "difficulty";
      difficultyButtons.innerText = "Difficulty: ";
      let normal = document.createElement("button");
      let hard = document.createElement("button");
      normal.id = "normal";
      hard.id = "hard";
      normal.innerText = "Normal";
      hard.innerText = "Hard";
      normal.onclick = () => {
        difficulty = "normal";
        switchDifficulty();
      };
      hard.onclick = () => {
        difficulty = "hard";
        switchDifficulty();
      };
      container.append(difficultyButtons);
      document.getElementById("difficulty").append(normal);
      document.getElementById("difficulty").append(hard);

      let startButton = document.createElement("button");
      startButton.id = "startButton";
      startButton.classList.add("hCentered");
      startButton.innerText = "Start game";
      container.append(startButton);

      switchMap();

      document.getElementById("game").onclick = null;
    }
    document.getElementById("game").onclick = showMaps;

    function switchMap() {
      map = maps[mapIndex];
      ctx.clearRect(480, 0, 960, 570);
      ctx.fillStyle = "white";
      ctx.font = "48px Segoe UI";
      ctx.textAlign = "center";
      ctx.fillText(`${map.name} by ${map.author}`, 960, 75);
      ctx.drawPreview(map); //Draw preview of map
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.strokeRect(480, 120, 960, 450);
      switchDifficulty();
    }

    function switchDifficulty() {
      let normal = document.getElementById("normal");
      let hard = document.getElementById("hard");
      let startButton = document.getElementById("startButton");
      let mapComplete = +progress[mapIndex];
      ctx.clearRect(0, 675, 1920, 275);
      ctx.fillStyle = "white";
      ctx.font = "30px Segoe UI";
      if (difficulty == "normal") {
        normal.classList.add("pressed");
        hard.classList.remove("pressed");
        ctx.fillText("• 50 waves", 960, 700);
        ctx.fillText("• 100 lives", 960, 750);
        if (mapComplete) {
          ctx.fillStyle = "#80ff80";
          ctx.fillText("✔️ Normal mode complete", 960, 935);
        }
      } else {
        hard.classList.add("pressed");
        normal.classList.remove("pressed");
        ctx.fillText("• 75 waves", 960, 700);
        ctx.fillText("• 50 lives", 960, 750);
        ctx.fillText("• No special powers", 960, 800);
        ctx.fillText("• Fast forward permanently on", 960, 850);
        if (mapComplete == 2) {
          ctx.fillStyle = "#80ff80";
          ctx.fillText("✔️ Hard mode complete", 960, 935);
        } else if (!mapComplete) {
          ctx.fillStyle = "#ff6860";
          ctx.fillText("🔒 Complete normal mode to unlock hard mode", 960, 935);
          startButton.classList.add("unselectable");
          startButton.onclick = null;
        }
      }
      if (difficulty == "normal" || mapComplete) {
        startButton.classList.remove("unselectable");
        startButton.onclick = startGame;
      }
    }

    function startGame() {
      //Alerts for maps with errors
      let errorMessage;
      if (!map.start || map.start.length != 2) errorMessage = "No start position given.";
      else if (!map.start.every(pos => Math.abs(pos % 1) == 0.5)) errorMessage = "Invalid start position. Path must start in the middle of a square.";
      else if (!map.lines || !map.lines.length) errorMessage = "No path given.";
      else if (!map.lines.every(line => ["up", "down", "left", "right"].includes(line[0]) && !isNaN(line[1]))) errorMessage = "Invalid path. Use the format [direction, length] for each segment of the path.";
      else if (!Array.isArray(map.waves)) errorMessage = "No waves included.";
      else if (map.waves.length < 75) errorMessage = "Not enough waves. Maps must include 75 waves.";
      else if (map.waves.length > 75) errorMessage = "Too many waves. Maps must include 75 waves.";
      else if (!map.waves.every(wave => Array.isArray(wave))) errorMessage = "Each wave must be contained inside an array.";
      if (errorMessage) {
        gameAlert("<b>Map error:</b> " + errorMessage, false, true);
        return;
      }

      document.getElementById("back").remove();
      document.getElementById("prevMap").remove();
      document.getElementById("nextMap").remove();
      document.getElementById("difficulty").remove();
      document.getElementById("startButton").remove();

      grid[0].fill("button", 0, (difficulty == "normal") ? 5 : 4); //Buttons in to top left
      grid[0].fill("info", 26, 32); //Area for game info in the top right

      //Make an array with one item for each pixel of the path
      mapArr = [];
      map.lines.forEach(line => {
        for (let i = 0; i < line[1] * 60; i++) mapArr.push(line[0]);
      });

      map.waves.forEach(wave => wave.unshift([8, pause])); //Add a break at the start of each wave

      planePathArr = mapArr.slice(60, -60); //Remove start and end for plane path
      //Make the plane return to the start once it reaches the end
      for (let i = planePathArr.length - 1; i >= 0; i--) {
        switch (planePathArr[i]) {
          case "right":
            planePathArr.push("left");
            break;
          case "left":
            planePathArr.push("right");
            break;
          case "down":
            planePathArr.push("up");
            break;
          case "up":
            planePathArr.push("down");
        }
      }

      superPlanePathArr = [];
      //SuperPlane moves from end to start
      for (let i = mapArr.length - 1; i >= 0; i--) {
        switch (mapArr[i]) {
          case "right":
            superPlanePathArr.push("left");
            break;
          case "left":
            superPlanePathArr.push("right");
            break;
          case "down":
            superPlanePathArr.push("up");
            break;
          case "up":
            superPlanePathArr.push("down");
        }
      }

      if (difficulty == "normal") {
        map.waves.splice(-25, 25); //Remove the last 25 waves
        animate = setInterval(update, 40); //Start the game at normal speed
      } else {
        player.lives = 50;
        fastForward = true;
        animate = setInterval(update, 10); //Start the game at a 4x speed
      }

      //Create the grid
      document.getElementById("grid").classList.remove("hidden")
      let gridHTML = "";
      grid.forEach((row, i) => {
        gridHTML += "<tr>"; //For every array in grid, add a row to the table
        row.forEach((square, j) => gridHTML += `<td id="r${i}c${j}"></td>`); //For every item in the array, add a cell to the row. If the item is not null, set the cell's class to the item's value
        gridHTML += "</tr>";
      });
      document.getElementById("grid").innerHTML = gridHTML;

      //Show the towers
      document.getElementById("towers").classList.remove("hidden");
      for (let tower in towerTypes) {
        document.getElementById("towers").innerHTML += `<img src="../../static/img/towerdefense/${tower}.png" id="${tower}">`;
        document.getElementById("powers").innerHTML += `<button id="${tower}Power" class="invisible">Use power</button>`;
      }
      for (let tower in towerTypes) {
        let towerEl = document.getElementById(tower);
        let powerButton = document.getElementById(tower + "Power");
        let power = towerTypes[tower].power;
        towerEl.onmouseover = () => document.getElementById("towerDesc").innerText = `${towerTypes[tower].name} · $${towerTypes[tower].price} · ${towerTypes[tower].description}`;
        towerEl.onmouseout = () => document.getElementById("towerDesc").innerText = null;
        powerButton.style.color = towerTypes[tower].color;
        powerButton.onmouseover = () => document.getElementById("towerDesc").innerText = power.description;
        powerButton.onmouseout = () => document.getElementById("towerDesc").innerText = null;
        powerButton.onclick = () => {
          if (power.bought && !power.cooldown && towers.find(owned => owned?.name == towerTypes[tower].name) && difficulty == "normal") {
            power.use();
            power.cooldown = 3000;
            power.used = true;
            if (Object.values(towerTypes).every(tower => tower.power.used)) gameAchievements[3] = 1;
          }
        };
      }

      this.onclick = null;
    };

    function gameAlert(message, large, error) {
      document.getElementById("r0c3")?.click(); //Pause the game
      let alertBox = document.createElement("div");
      alertBox.id = "alert";
      alertBox.classList.add("centered");
      alertBox.classList.add("light");
      if (large) alertBox.classList.add("large");
      if (error) alertBox.classList.add("error");
      let alertText = document.createElement("div");
      alertText.id = "alertText";
      alertText.innerHTML = message;
      alertBox.append(alertText);
      let okButton = document.createElement("button");
      okButton.id = "ok";
      okButton.innerText = "OK";
      okButton.onclick = hideAlert;
      alertBox.append(okButton);
      document.getElementById("container").append(alertBox);
      document.addEventListener("keydown", hideAlert);
    }

    function hideAlert() {
      document.getElementById("alert").remove(); //Hide the alert box
      if (paused) document.getElementById("r0c0").click(); //Unpause the game
      document.removeEventListener("keydown", hideAlert);
    }

    function endGame(complete) {
      if (complete) {
        sound.playSFX("success");
        let num = (difficulty == "hard") ? 2 : 1;
        if (progress[mapIndex] < num) progress.splice(mapIndex, 1, num); //Update progress
        //Save to the database as a string
        let request1 = new XMLHttpRequest();
        request1.open("POST", "/updateuser?field=tdProgress&value=" + progress.join(""));
        request1.send();
      } else {
        sound.playSFX("shoot");
        gameAchievements[4] = 0;
        gameAchievements[5] = 0;
        gameAchievements[6] = 0;
      }
      let allAchievements = achievements.map((achievement, i) => +achievement || gameAchievements[i]); //New achievements + ones that were earned before
      let request2 = new XMLHttpRequest();
      request2.open("POST", "/updateuser?field=tdAchievements&value=" + allAchievements.join(""));
      request2.send();
      completeMaps = progress.reduce((a, b) => +a + +b);
      completeAchv = achievements.reduce((a, b) => +a + +b);
      let totalComplete = completeMaps + completeAchv;
      if (totalComplete) {
        let request3 = new XMLHttpRequest();
        request3.open("POST", "/savescore?game=towerdefense&score=" + totalComplete);
        request3.send();
      }
      //If a tower has a menu open, close it
      let menuTower = towers.find(tower => tower?.menuOpen);
      menuTower?.closeMenu();
      clearInterval(animate);
      ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas
      document.getElementById("grid").classList.add("hidden");
      document.getElementById("towers").classList.add("hidden");
      ctx.fillStyle = "white";
      ctx.font = "128px Segoe UI";
      ctx.textAlign = "center";
      ctx.fillText(complete ? "Map complete!" : "Game over", 960, 300);
      ctx.font = "64px Segoe UI";
      ctx.fillStyle = "#80ffff";
      ctx.fillText(complete ? `${map.name} cleared on ${difficulty} mode` : `You lost on wave ${currentWave + 1}`, 960, 500);
      ctx.fillStyle = "#ffdf40";
      let newAchievements = achievements.filter((achievement, i) => !+achievement && gameAchievements[i]).length;
      if (newAchievements) ctx.fillText(`${newAchievements} new ${(newAchievements == 1) ? "achievement" : "achievements"} earned`, 960, 600);
      ctx.font = "48px Segoe UI";
      ctx.fillStyle = "white";
      ctx.fillText("Click to return to the home screen", 960, 800);
      document.getElementById("game").onclick = () => window.location.reload();
    }
  }
</script>
{% endblock %}